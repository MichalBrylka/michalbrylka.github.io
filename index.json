[{"categories":["programming"],"content":"Protocol buffers (aka. protobuf for short) is very efficient serialization format. Usually implementations provided by library maintainers (i.e. Protobuf ports for various frameworks) are optimal and are only getting better with time. Recently I needed to use Confluent Kafka‚Äôs implementation of protobuf deserializer and to my astonishment, deserialization operation is not optimal. Deserialization operation the one that my project needed the most as we were producing messages in off-work times but main system is consuming them in high-traffic periods. Let‚Äôs see how we might remedy this issue. ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:0:0","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Deserializer Luckily for us, Confluent.Kafka package is open source and can be found here. Indeed, upon inspection of ProtobufDeserializer.cs we can suspect that our culprit are: data.ToArray(); using (var stream = new MemoryStream(array)) using (var reader = new BinaryReader(stream)) These design decision were probably caused by the fact that there was no convenient and official API for reading data from Span/ReadOnlySpan. There is few unofficial ones, you can read about my approach here. Fortunately for us, Confluent made Kafka to be really nicely composable so we can provide our own deserializer. The only thing we need to read upon deserialization are: Magic byte (zero) to indicate a message with Confluent Platform framing 4 byte schema ID. Since this is not needed as we know deserialized type‚Äôs metadata (this can be taken from generic type) - we can safely ignore this portion of data (but stream pointer needs to move) Unsigned/Signed variable-length encoded integers (Varint) that denotes array length - and then subsequently reading these indices Reading payload itself - this can be delegated to underlying Protobuf library (by Google in my/Confluent‚Äôs case) So our Deserialize method can look like that: public T? Deserialize(ReadOnlySpan\u003cbyte\u003e data, bool isNull, SerializationContext context) { if (isNull) return null; if (data.Length \u003c 6) throw new InvalidDataException( \"Expecting data framing of length 6 bytes or more but total data size is \" + $\"{data.Length} bytes\"); var spanReader = new SpanBinaryReader(data); var magicByte = spanReader.ReadByte(); if (magicByte != MagicByte) throw new InvalidDataException( $\"Expecting message {context.Component} with Confluent Schema Registry framing.\" + $\"Magic byte was {magicByte}, expecting {MagicByte}\"); // A schema is not required to deserialize protobuf messages since the serialized data includes // tag and type information, which is enough for the IMessage\u003cT\u003e implementation to deserialize // the data (even if the schema has evolved). // Schema Id is thus unused. Just advancing by 4 bytes is enough spanReader.Seek(4); //var _schemaId = IPAddress.NetworkToHostOrder(spanReader.ReadInt32()); // Read the index array length, then all of the indices. These are not needed, // but parsing them is the easiest way to seek to the start of the serialized data // because they are varints. var indicesLength = _useDeprecatedFormat ? (int)spanReader.ReadUnsignedVarint() : spanReader.ReadVarint(); for (int i = 0; i \u003c indicesLength; ++i) if (_useDeprecatedFormat) spanReader.ReadUnsignedVarint(); else spanReader.ReadVarint(); return _parser.ParseFrom(spanReader.Remaining()); } Full implementation can be found here. During optimizations I‚Äôve noticed that Confluent‚Äôs implementation only implementsIAsyncDeserializer\u003c\u003ewhereas implementingIDeserializer\u003c\u003eshould be sufficient - we are not doing any async work there. ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:1:0","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Benchmarks ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:2:0","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Unit benchmarks This benchmark tests what the performance and memory footprint of every approach are. Full results are located in the same file, let me just present excerpt of it (pay no attention to NonAlloc* benchmarks, they we just there for tests): Method Mean Error StdDev Ratio Gen 0 Gen 1 Allocated Confluent 12,087.8 ns 117.93 ns 110.31 ns 1.00 8.2779 0.1678 52,003 B EfficientAsync 4,995.7 ns 52.32 ns 48.94 ns 0.41 0.9689 - 6,080 B EfficientSync 4,838.4 ns 80.18 ns 75.00 ns 0.40 0.8545 - 5,360 B Especially after presenting same data on interactive chart: one can clearly see the trend that Confluent‚Äôs implementation is adding (unnecessary) allocations and partially due to that they are significantly slower. Moreover, my synchronous version is only slightly (‚Äúnegligibly‚Äù) faster than my async counterpart. But since there is really no point of using async here - synchronous deserializer might me our variant of choice. ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:2:1","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Full operation benchmarks Ok we see where this is going. Performance benefits are visible but one can argue that they might not be significant. After all, Kafka internally allocates a lot of things (message itself, TopicPartitionOffset, ConsumeResult etc.). They all clearly would dwarf performance benefits we‚Äôve just obtained. Let‚Äôs measure that. Here I tried to recreate the whole pipeline that Confluent‚Äôs Kafka performs upon message deserialization. These are the results: Method Mean Error StdDev Ratio Gen 0 Gen 1 Allocated Create 1,049.5 ns 18.40 ns 26.97 ns 1.00 0.9937 0.0019 6,240 B Confluent 8,116.3 ns 92.92 ns 82.37 ns 7.65 8.6670 0.1221 54,403 B EfficientAsync 5,137.8 ns 96.98 ns 99.59 ns 4.85 1.3504 - 8,480 B EfficientSync 4,993.0 ns 34.52 ns 32.29 ns 4.71 1.2360 - 7,760 B Create benchmark is there just to demonstrate amount of memory/performance that deserialize operation would have without any calls to Protobuf deserializer. Again, the difference both in performance and memory allocations is clear‚Ä¶ ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:2:2","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Summary We‚Äôve demonstrated that eliminating allocations allows us to harvest low hanging fruits in performance realm. We are using this deserializer on production and it seem‚Äôs fine. I¬†did not prepare any Nuget package with that solution but can provide one if the need arrives. I filed an issue and offered a pull request. So far a claim was offered that at some point in the future this might be implemented. Fingers crossed. Upvote üëç if you care to include my change in official release. Subscribe to this issue on Github to stay tuned for more info üññ. ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:3:0","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Sources EfficientProtobufDeserializer Tests ","date":"2023-01-09","objectID":"/posts/kafka-protobuf-deserializer/:4:0","tags":["csharp","performance","kafka","protobuf"],"title":"Kafka Protobuf Deserializer","uri":"/posts/kafka-protobuf-deserializer/"},{"categories":["programming"],"content":"Span/ReadOnlySpan represent marvelous way to represent contiguous memory in .NET be it managed and unmanaged resources, strings or stack-allocated values. What they lack however is convenience in reading/writing using build in functions or dedicated reader/writer. Today I‚Äôll try to address the former utility structure. ","date":"2023-01-04","objectID":"/posts/span-binary-reader/:0:0","tags":["csharp","performance"],"title":"Span binary reader","uri":"/posts/span-binary-reader/"},{"categories":["programming"],"content":"Reader design In order to create a wrapper around ref-structure we need to define ref struct as well: public ref struct SpanBinaryReader { private readonly ReadOnlySpan\u003cbyte\u003e _buffer; private int _position; // Current position public int Position =\u003e _position; // Length of underlying buffer public int Length =\u003e _buffer.Length; public SpanBinaryReader(ReadOnlySpan\u003cbyte\u003e buffer, int position = 0) { _buffer = buffer; _position = position; } } In order to be familiar to developer we will try to follow BinaryReader API logic by defining similar seek/position features: // Reset current position to default (0) public void Reset() =\u003e _position = 0; // Advance (or retreat) current position by given amount // Offset parameter indicates number of bytes to advance position by // or retreat by in case of negative numbers public void Seek(int offset) { var newPosition = _position + offset; if (newPosition \u003c 0) throw new ArgumentOutOfRangeException(nameof(offset), offset, $\"After advancing by {nameof(offset)} parameter, \" + \"position should point to non-negative number\"); _position = newPosition; } // Determines if end of buffer was reached public bool IsEnd =\u003e _position \u003e= _buffer.Length; as well as ReadXXX methods: // Reads 1 byte from underlying stream. Returns byte read or -1 if EOB is reached [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ReadByte() =\u003e _position \u003e= _buffer.Length ? -1 : _buffer[_position++]; // Reads one little endian 16 bits integer from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public short ReadInt16() =\u003e BinaryPrimitives.ReadInt16LittleEndian(ReadExactly(2)); // Reads one little endian 32 bits integer from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ReadInt32() =\u003e BinaryPrimitives.ReadInt32LittleEndian(ReadExactly(4)); // Reads one little endian 64 bits integer from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public long ReadInt64() =\u003e BinaryPrimitives.ReadInt64LittleEndian(ReadExactly(8)); // Reads boolean value from underlying stream. Returns true if byte read is non-zero, false otherwise [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool ReadBoolean() =\u003e ReadExactly(1) is var slice \u0026\u0026 slice[0] != 0; // Reads one little endian 32 bits floating number from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public float ReadSingle() =\u003e BinaryPrimitives.ReadSingleLittleEndian(ReadExactly(4)); // Reads one little endian 64 bits floating number from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public double ReadDouble() =\u003e BinaryPrimitives.ReadDoubleLittleEndian(ReadExactly(8)); // Reads one little endian 128 bits decimal number from underlying stream [MethodImpl(MethodImplOptions.AggressiveInlining)] public decimal ReadDecimal() { int lo = ReadInt32(); int mid = ReadInt32(); int hi = ReadInt32(); int flags = ReadInt32(); return new decimal(lo, mid, hi, (flags \u0026 0b_1000_0000_0000_0000_0000_0000_0000_0000) != 0, (byte)((flags \u003e\u003e 16) \u0026 0xFF)); } and remaining helper Read methods (code might me collapsed as it‚Äôs a bit longer): // Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read. [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ReadTo(Span\u003cbyte\u003e buffer) { int n = Math.Min(Length - Position, buffer.Length); if (n \u003c= 0) return 0; _buffer.Slice(_position, n).CopyTo(buffer); _position += n; return n; } // Reads buffer of given size at most [MethodImpl(MethodImplOptions.AggressiveInlining)] public ReadOnlySpan\u003cbyte\u003e Read(int numBytes) { if (numBytes \u003c 0) throw new ArgumentOutOfRangeException(nameof(numBytes), $\"'{numBytes}' should be non negative\"); int n = Math.Min(Length - Position, numBytes); if (n \u003c= 0) return ReadOnlySpan\u003cbyte\u003e.Empty; var result = _buffer.Slice(_position, n); _position += n; return result; } // Reads buffer of exact given size [MethodImpl(MethodImplOptions.AggressiveIn","date":"2023-01-04","objectID":"/posts/span-binary-reader/:1:0","tags":["csharp","performance"],"title":"Span binary reader","uri":"/posts/span-binary-reader/"},{"categories":["programming"],"content":"Summary We were able to define a utility structure that could help in easy reading of data from spans so that neither high performance nor convenience are hindered. Next time we will see how these routines can help in solving real life performance issue üöÄ. Stay tuned for more info üññ. ","date":"2023-01-04","objectID":"/posts/span-binary-reader/:2:0","tags":["csharp","performance"],"title":"Span binary reader","uri":"/posts/span-binary-reader/"},{"categories":["programming"],"content":"Sources SpanBinaryReader sources SpanBinaryReader tests Nemesis.Essentials package contains SpanBinaryReader and other classes that should be contained in .NET but somehow are not ","date":"2023-01-04","objectID":"/posts/span-binary-reader/:3:0","tags":["csharp","performance"],"title":"Span binary reader","uri":"/posts/span-binary-reader/"},{"categories":["ideas"],"content":"There are multiple ways of planning your daily source control workflow. In most cases you need to contain commit message that contains some kind of bug tracker number (like Jira, YouTrack etc.). Checks are usually installed as Git hooks and consequently commits may be revoked during push phase if they do not meet certain criteria. Let me introduce a quick tip that may speed your work (especially) when dealing with numerous issues during the day. This post describes how things can be achieved in Git SCM but similar workflows can be obtained in Mercurial as well. ","date":"2023-01-02","objectID":"/posts/commit-driven-development/:0:0","tags":["tips","git"],"title":"Commitment driven development","uri":"/posts/commit-driven-development/"},{"categories":["ideas"],"content":"TDD Most of us are familiar with test-driven development approach. Even if we do not use it in our project (which usually means it‚Äôs not test-oriented), TDD concept must be known by heart as it‚Äôs a favorite topic among job recruiters üòâ. TDD as a methodology usually pivots around cycles that may look like that: \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e image/svg+xml Testsfail Testspass Refactor TDDcircleof life It gives us more benefit if we are familiarized with it as follows: Make it work. Make it right. Make it fast. But usually this cycle is described for short as Red-Green-Refactor. I usually go one step forward and rephrase it as (Git/Mercurial only): red-commit(s)-green-commit(s)-refactor-commit(s)-squash-push It‚Äôs advisable to squash all (or most - depending on context) commits before pushing. Commits that we push outside should contain meaningful changes so that describing them should be easy. ","date":"2023-01-02","objectID":"/posts/commit-driven-development/:1:0","tags":["tips","git"],"title":"Commitment driven development","uri":"/posts/commit-driven-development/"},{"categories":["ideas"],"content":"Commitment driven development Usual Git workflow dictates to perform some work, add our changes and commit them later on. We could however commit our work first and somewhat reverse this process. This way we are making a commitment to what we currently are dealing with. After all commitment is defined as the state or quality of being dedicated to a cause, activity, etc. Git allows us to commit no changes by using git commit --allow-empty -m \"Some message\" Commits in source control should be coherent and contain commit message - at least these that are later on pushed to remote. I like to have small and coherent branches that get merged frequently - which has added benefit of close-to-zero merge conflicts. Thus I like to start with meaningful commit message that contains necessary bug track number and a description that will become final commit message after squash. Subsequent commit messages can be short or even gibberish as they (messages, not commits) will usually be discarded upon squashing of commits. Also sharing our history ‚Äúmilestones‚Äù like ‚Äúadded/fixed test XXX‚Äù is not adding value in most cases. This script helps me in my workflow: \u003c# .SYNOPSIS Create WIP commit message .EXAMPLE .\\PutCddGitMessage.ps1 \"Implement new important feature\" Example output [feature/New-12345 b0d2215] New-12345 Implement new important feature #\u003e [CmdletBinding()] param ( [Parameter(Mandatory = $True)] [ValidateNotNullOrEmpty()] [Alias(\"m\")] [string]$message ) $branchName = git branch --show-current if (($LASTEXITCODE -eq 0) -and ($branchName -match '.*?\\/?(?\u003cIssue\u003e\\w+-\\d+)')) { $issue = $Matches. Issue $message = $message.Replace(\"\\`\"\", \"\") $commitMessage = \"${issue} ${message}\" git commit --allow-empty -m \"$commitMessage\" } else { Write-Error \"Not a git repo or invalid branch name (i.e. feature/PROJ-666)\" } So right after creation of feature/bug branch I call: PutCddGitMessage.ps1 \"Implement optimized value string builder\" Let‚Äôs assume that branch name was feature/PROJ-666 then my generated commit message will be ‚ÄúPROJ-666 Implement optimized value string builder‚Äù I can start adding some files/changes. They can be then committed: git add . git commit --amend Commits can contain code that does not compile and tests that are failing (in red phase). Our branch is ours to use and only when we are synchronizing changes with others - they need to be coherent, contain meaningful messages, perfect (un-flaky) tests and refactored codebase - at least to extent of our current change. ","date":"2023-01-02","objectID":"/posts/commit-driven-development/:2:0","tags":["tips","git"],"title":"Commitment driven development","uri":"/posts/commit-driven-development/"},{"categories":["ideas"],"content":"Summary We introduced a simple script that may speed your daily workflow. Whether you install it as a module, script or a¬†function in PowerShell profile, it‚Äôs up to you. As an added bonus Commitment Driven Development approach serves you as a reminder of what you‚Äôre dealing with currently. You just type: git log -n1 and your intentions for next few moments are clear. Forgetting what you are currently doing is not that uncommon especially in large teams. It doesn‚Äôt happen to you but this particular mini tip may help your colleague greatly üòâ. After all, one can assume (both in real life as well as development) that: You won‚Äôt achieve anything unless you commit (to) everything ","date":"2023-01-02","objectID":"/posts/commit-driven-development/:3:0","tags":["tips","git"],"title":"Commitment driven development","uri":"/posts/commit-driven-development/"},{"categories":["programming"],"content":"There are times when we need to automatically convert certificate for SSL, signatures and other things. Certificates usually expire every now and then so nobody reasonable likes to sit and wait till it does and only then perform some manual tasks. Tools like OpenSSL are usually the way to go when we control where our certificates are deployed. Sometimes a custom solutions is needed. In my case this conversion was about circumventing a subtle bug in librdkafka that manifested itself into Confluent.Kafka. More on that issue can be read here. As of writing this article, this issue is resolved but it didn‚Äôt find it‚Äôs way into any release (current release is 1.9.3, newest can be found at Confluent.Kafka ). I thus needed to open P12 file format, decrypt it and put it in secure location as PEM file. ","date":"2022-12-27","objectID":"/posts/certificate-convert/:0:0","tags":["cryptography","powershell","scripts"],"title":"Certificate converter","uri":"/posts/certificate-convert/"},{"categories":["programming"],"content":"Conversion These are many approaches to solve cryptographic problems in .NET. Many of them pivot around using $3^{rd}$ part library like Bouncy Castle, but nowadays there finally exists a modern Crypto API in .NET itself - I decided to give it a try. This is a simple code that opens any certificate, takes it‚Äôs private key (I needed just RSA scheme but other approaches also seem to work) and convert it nicely to PEM format using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; var (input, password, output) = args.Length switch { 2 =\u003e (args[0], args[1], Path.ChangeExtension(args[0], \".pem\")), 3 =\u003e (args[0], args[1], args[2]), _ =\u003e throw new ArgumentException( \"Pass either 2 (input, password) or 3 arguments (input, password, output)\", nameof(args)), }; var pem = ConvertToPem(input, password); File.WriteAllText(output, pem); static string ConvertToPem(string filename, string password) { using var cert = new X509Certificate2(filename, password, X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); var certPem = new string(PemEncoding.Write(\"CERTIFICATE\", cert.RawData)); using var certAlgorithm = cert.GetRSAPrivateKey() as AsymmetricAlgorithm ?? cert.GetECDsaPrivateKey() as AsymmetricAlgorithm ?? cert.GetDSAPrivateKey() as AsymmetricAlgorithm ?? cert.GetECDiffieHellmanPrivateKey() as AsymmetricAlgorithm ?? throw new CryptographicException(\"Unknown certificate algorithm\"); var keyPem = new string(PemEncoding.Write(\"PRIVATE KEY\", certAlgorithm.ExportPkcs8PrivateKey())); return certPem + Environment.NewLine + keyPem; } Similar program needed to run on Windows production machine that obviously will never have .NET SDK installed (and deploying additional binaries is generally tedious in certain environments). So a script equivalent was needed. I created the code above in C# as I‚Äôm more fluent at C# then I‚Äôll ever be at Powershell. This is my attempt to rewrite to Powershell. If it looks to imperative to your taste, I‚Äôm open to any suggestions on how this can be improved to appear more like hard-core script that a seasoned admin would not scoff at üòÄ ","date":"2022-12-27","objectID":"/posts/certificate-convert/:1:0","tags":["cryptography","powershell","scripts"],"title":"Certificate converter","uri":"/posts/certificate-convert/"},{"categories":["programming"],"content":"Sources Certificate converter ","date":"2022-12-27","objectID":"/posts/certificate-convert/:2:0","tags":["cryptography","powershell","scripts"],"title":"Certificate converter","uri":"/posts/certificate-convert/"},{"categories":["programming"],"content":"C# 11.0 generic math is very powerful extension to already capable generic types system present in C# since version 2.0. Besides static interface members there are couple of changes that make it easier to express math concepts in C#. Let‚Äôs see what needed to change in order to add this neat feature. Note This blog post participates in C# Advent Calendar 2022. Expect around 50 awesome posts this month, with 2 being revealed every day. It‚Äôs digital/C#-oriented counterpart of old German tradition ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:0:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Interfaces and operations While generic math is C# 11 feature, there were some new additions in .NET framework itself. In order to facilitate appropriate abstraction, the following interfaces were introduced and numeric/built-in types subsequently started implementing them: Interface Description INumberBase Base interface for all numbers INumber All members related to numbers. Extends INumberBase mostly for comparison operations IParseable Parse(string, IFormatProvider) ISpanParseable Parse(ReadOnlySpan, IFormatProvider) IAdditionOperators x + y IBitwiseOperators x \u0026 y, x | y, x ^ y and ~x IComparisonOperators x \u003c y, x \u003e y, x \u003c= y, and x \u003e= y IDecrementOperators ‚Äìx and x‚Äì IDivisionOperators x / y IEqualityOperators x == y and x != y IIncrementOperators ++x and x++ IModulusOperators x % y IMultiplyOperators x * y IShiftOperators x ¬´ y and x ¬ª y ISubtractionOperators x - y IUnaryNegationOperators -x IUnaryPlusOperators +x IAdditiveIdentity (x + T.AdditiveIdentity) == x IMinMaxValue T.MinValue and T.MaxValue IMultiplicativeIdentity (x * T.MultiplicativeIdentity) == x IBinaryFloatingPoint Members common to binary floating-point types IBinaryInteger Members common to binary integer types IBinaryNumber Members common to binary number types IFloatingPoint Members common to floating-point types INumber Members common to number types ISignedNumber Members common to signed number types IUnsignedNumber Members common to unsigned number types List of all of them can be found on MSDN ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:1:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Checked operators In C# 11 it is now possible to specify operators as checked. Compiler will select appropriate version depending on context (Visual Studio will navigate to appropriate operator definition upon pressing /‚ÄúGo to definition‚Äù). Let‚Äôs see that on example: readonly record struct Point(int X, int Y) { public static Point operator checked +(Point left, Point right) =\u003e checked(new(left.X + right.X, left.Y + right.Y)); public static Point operator +(Point left, Point right) =\u003e new(left.X + right.X, left.Y + right.Y); } //usage var point = new Point(int.MaxValue - 1, int.MaxValue - 2); //Point { X = 2147483646, Y = 2147483645 } var @unchecked = unchecked(point + point); //Point { X = -4, Y = -6 } var @checked = checked(point + point); //‚ö†Ô∏è throws System.OverflowException ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:2:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Identity element and constants Every number type usually (always for C# numbers but that is not necessarily the case in math) has some identity elements for most popular operations (addition and multiplication). The following listing demonstrates them using generic guard as these constants are not publicly exposed private static void Constants\u003cT\u003e() where T : INumber\u003cT\u003e { var one = T.One; var zero = T.Zero; var additiveIdentity = T.AdditiveIdentity; var multiplicativeIdentity = T.MultiplicativeIdentity; } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:3:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Conversions In order to be able to smoothly convert numbers from other number types, several methods were added: CreateChecked - convert ‚Äúexactly‚Äù or throw if number falls outside the representable range CreateSaturating - convert values saturating any values that fall outside the representable range CreateTruncating - convert values truncating any values that fall outside the representable range //specifying generic type is not needed, it's just here for clarity var b1 = byte.CreateSaturating\u003cint\u003e(300); //255 var b2 = byte.CreateTruncating(300); //44 var b3 = byte.CreateChecked(300); //‚ö†Ô∏è Arithmetic operation resulted in an overflow. var b4 = byte.CreateChecked(3.14); //3 ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:4:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Dedicated functions New function were introduced to built-in types to facilitate typical operation that we perform with given number groups. //Check if integer is power of two. Equivalent to BitOperations.IsPow2(1024) var isPow = int.IsPow2(1024); // true //Population count (number of bits set). Same as BitOperations.PopCount(15) - vectorized if possible var pop = int.PopCount(15); // 4 //Cubic root of a specified number. Equivalent to MathF.Cbrt(x) var cbrt = float.Cbrt(8.0f); // 2 //Sine of the specified angle (in radians). Equivalent to MathF.Sin(x) var sin = float.Sin(float.Pi / 6.0f); //0.5 For more functions see list for integers or floating point numbers. Other interesting function groups are: ITrigonometricFunctions IRootFunctions IPowerFunctions ILogarithmicFunctions ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:5:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Matrix definition We are now ready to propose a new type that will denote a generic matrix of number-like structures. Make sure to read a post about static interface members if that concept is still new to you. ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Structure Let‚Äôs start with simple definition. Just for fun we will be restricting our number generic parameter to unmanaged types. This is not strictly needed for our example but it will allow for some tricks like faster array enumeration public partial class Matrix\u003cTNumber\u003e //for now we are not extending any interface where TNumber : unmanaged //needed for pointer \"magic\" { private readonly TNumber[,] _data; public int Rows { get; } public int Columns { get; } public int Size { get; } public TNumber this[int iRow, int iCol] =\u003e _data[iRow, iCol]; public Matrix(TNumber[,] data) { _data = data; Rows = data.GetLength(0); Columns = data.GetLength(1); Size = Rows * Columns; } //optionally we'd like to be able to create Matrix using 1-D array with certain number of columns public unsafe Matrix(TNumber[] data, int columns) { var data2d = new TNumber[data.Length / columns, columns]; fixed (TNumber* pSource = data, pTarget = data2d) { for (int i = 0; i \u003c data.Length; i++) pTarget[i] = pSource[i]; } _data = data2d; Rows = data2d.GetLength(0); Columns = data2d.GetLength(1); } } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:1","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Matrix operations While this class already is able to store some data, we would not be able to do anything meaningful with it. Let‚Äôs add our first math operation - addition. Since that operation uses only addition and needs to be seeded with zero (additive identity) we could modify our generic guard to: class Matrix where TNumber : unmanaged, IAdditionOperators\u003cTNumber, TNumber, TNumber\u003e, IAdditiveIdentity\u003cTNumber, TNumber\u003e { /*...*/ public unsafe TNumber Sum() { var result = TNumber.AdditiveIdentity; fixed (TNumber* pData = _data) //use pointers to be able to iterate array faster { var p = pData; for (int i = 0; i \u003c Size; i++) result += *p++; } return result; } } but we would be better off when that guard would be changed to public partial class Matrix\u003cTNumber\u003e where TNumber : unmanaged, //it is just necessary to mark number type appropriately to be able to use it in generic contexts INumberBase\u003cTNumber\u003e { /*...*/ public unsafe TNumber Sum() { //\"Zero\" also looks more natural in that context as opposed to \"AdditiveIdentity\" var result = TNumber.Zero; fixed (TNumber* pData = _data) { var p = pData; for (int i = 0; i \u003c Size; i++) result += *p++; } return result; } } Summation is obviously useful but it‚Äôs also trivial in it‚Äôs form. For instance let‚Äôs consider C# whole number types. Like in math, natural and integer numbers are closed under addition. When you consider other operations on these numbers, say division, this is no longer the case. While we could calculate an average of integers in C# as follows var intArray = new[] { 1, 2, 4 }; var avg = intArray.Sum() / intArray.Length; //2 it would be more convenient to convert result and intermediate operations to floating point numbers. Even LINQ function does that: var avgLinq = intArray.Average(); //2.3333333333333335 This conversion will do the trick for our matrix: public unsafe TResult Sum\u003cTResult\u003e() where TResult : INumber\u003cTResult\u003e { var result = TResult.Zero; fixed (TNumber* pData = _data) { var p = pData; for (int i = 0; i \u003c Size; i++) result += TResult.CreateChecked(*p++); } return result; } // now Average can use Sum\u003cTResult\u003e public TResult Average\u003cTResult\u003e() where TResult : INumber\u003cTResult\u003e { TResult sum = Sum\u003cTResult\u003e(); return sum / TResult.CreateChecked(Size); } No matrix is complete without Determinant function. While there are dozens of algorithms to do that, I‚Äôll use a¬†plain decomposition approach due to it‚Äôs simplicity public TNumber Determinant() { if (Rows != Columns) throw new(\"Determinant of a non-square matrix doesn't exist\"); var det = TNumber.Zero; if (Rows == 1) return this[0, 0]; if (Rows == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0]; for (int j = 0; j \u003c Columns; j++) { TNumber reduced = this[0, j] * Minor(0, j).Determinant(); if (j % 2 == 1) reduced = -reduced; det += reduced; } return det; } public Matrix\u003cTNumber\u003e Minor(int iRow, int iCol) { var minor = new TNumber[Rows - 1, Columns - 1]; int m = 0; for (int i = 0; i \u003c Rows; i++) { if (i == iRow) continue; int n = 0; for (int j = 0; j \u003c Columns; j++) { if (j == iCol) continue; minor[m, n] = this[i, j]; n++; } m++; } return new(minor); } Similarly it might be useful to obtain largest and smallest element in matrix. Since that requires some comparisons, let‚Äôs add IComparisonOperators\u003cTNumber, TNumber, bool\u003e interface to our generic guard for TNumber. Doing so enables us to then use comparison operators. We will however lose (as a consequence) the ability of using types that do not possess relational ordering - Complex type being most notable here Note Using IComparisonOperators\u003cTNumber, TNumber, bool\u003e is somewhat limiting. It‚Äôs probably more important to be able to use final matrix with types like Complex especially if Min/Max operation could be added using different approach. So final design of matrix might reflect that notion public unsafe TNumber Min() { if (Size == 0) throw new(\"Matrix is empty\"); TNumber result; fixed (TNumber* pData = _data) { var p = pData; result = *p; for (int ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:2","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Matrix operators Have a look at the following operators (code example might need expanding): //add 2 matrices public unsafe static Matrix\u003cTNumber\u003e operator +(Matrix\u003cTNumber\u003e left, Matrix\u003cTNumber\u003e right) { if (left.Rows != right.Rows || left.Columns != right.Columns) throw new(\"Sum of 2 matrices is only possible when they are same size\"); var data = new TNumber[left.Rows, left.Columns]; var size = left.Rows * left.Columns; fixed (TNumber* lSource = left._data, rSource = right._data, target = data) { for (int i = 0; i \u003c size; i++) target[i] = lSource[i] + rSource[i]; //checked operator version would differ only in this line } return new Matrix\u003cTNumber\u003e(data); } //right-side operator for adding single number element-wise public unsafe static Matrix\u003cTNumber\u003e operator +(Matrix\u003cTNumber\u003e left, TNumber right) { var data = new TNumber[left.Rows, left.Columns]; var size = left.Rows * left.Columns; fixed (TNumber* lSource = left._data, target = data) { for (int i = 0; i \u003c size; i++) target[i] = lSource[i] + right; } return new Matrix\u003cTNumber\u003e(data); } // Multiplication. More efficient function might be chosen for production code. // This is just to illustrate this operator public static Matrix\u003cTNumber\u003e operator *(Matrix\u003cTNumber\u003e a, Matrix\u003cTNumber\u003e b) { int rowsA = a.Rows, colsA = a.Columns, rowsB = b.Rows, colsB = b.Columns; if (colsA != rowsB) throw new(\"Matrixes can't be multiplied\"); var data = new TNumber[rowsA, colsB]; for (int i = 0; i \u003c rowsA; i++) { for (int j = 0; j \u003c colsB; j++) { var temp = TNumber.Zero; for (int k = 0; k \u003c colsA; k++) temp += a[i, k] * b[k, j]; data[i, j] = temp; } } return new Matrix\u003cTNumber\u003e(data); } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:3","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Parsing No math structure is complete without parsing and formatting routines. We would like to support multiple matrix definition formats like: Matlab: [1,2,3 ; 4,5,6 ; 7,8,9] Mathematica: {{1,2,3},{4,5,6},{7,8,9}} natural notation: The code below might do the trick (full code is linked at the end of current article): /// \u003csummary\u003eParsing and formatting operation for matrices\u003c/summary\u003e public interface IMatrixTextFormat { /// \u003csummary\u003e /// Parse matrix from text buffer /// \u003c/summary\u003e Matrix\u003cTNumber\u003e Parse\u003cTNumber\u003e(ReadOnlySpan\u003cchar\u003e s) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e; /// \u003csummary\u003e /// Attempt to format current matrix in provided text buffer /// \u003c/summary\u003e bool TryFormat\u003cTNumber\u003e(Matrix\u003cTNumber\u003e matrix, Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e; } public readonly struct StandardFormat : IMatrixTextFormat { private readonly IFormatProvider _underlyingProvider; private readonly NumberStyles? _numberStyles; private readonly char _elementSeparator; private static readonly char[] _rowSeparators = Environment.NewLine.ToCharArray(); public StandardFormat() : this(CultureInfo.InvariantCulture) { } public StandardFormat(IFormatProvider? underlyingProvider, NumberStyles numberStyles = NumberStyles.Any) { _numberStyles = numberStyles; _underlyingProvider = underlyingProvider ?? CultureInfo.InvariantCulture; (_underlyingProvider, _elementSeparator) = GetParameters(); } private (IFormatProvider Provider, char ElementSeparator) GetParameters() { var provider = _underlyingProvider ?? CultureInfo.InvariantCulture; char elementSeparator = _elementSeparator != '\\0' ? _elementSeparator : (provider is CultureInfo ci ? ci.TextInfo.ListSeparator.Trim().Single() : ';'); return (provider, elementSeparator); } public Matrix\u003cTNumber\u003e Parse\u003cTNumber\u003e(ReadOnlySpan\u003cchar\u003e s) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e { var (provider, elementSeparator) = GetParameters(); var numberStyles = _numberStyles ?? NumberStyles.Any; var rowsEnumerator = s.Split(_rowSeparators, true).GetEnumerator(); if (!rowsEnumerator.MoveNext()) throw new FormatException(\"Non empty text is expected\"); var firstRow = rowsEnumerator.Current; int numCols = 0; using var buffer = new ValueSequenceBuilder\u003cTNumber\u003e(stackalloc TNumber[32]); foreach (var col in firstRow.Split(elementSeparator, true)) { if (col.IsEmpty) continue; buffer.Append(TNumber.Parse(col, numberStyles, provider)); numCols++; } int numRows = 1; while (rowsEnumerator.MoveNext()) { var row = rowsEnumerator.Current; if (row.IsEmpty) continue; foreach (var col in row.Split(elementSeparator, true)) { if (col.IsEmpty) continue; buffer.Append(TNumber.Parse(col, numberStyles, provider)); } numRows++; } var matrix = new TNumber[numRows, numCols]; buffer.AsSpan().CopyTo2D(matrix); return new Matrix\u003cTNumber\u003e(matrix); } public bool TryFormat\u003cTNumber\u003e(Matrix\u003cTNumber\u003e matrix, Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e { var (provider, elementSeparator) = GetParameters(); var newLine = _rowSeparators.AsSpan(); var newLineLen = newLine.Length; int charsWrittenSoFar = 0; for (int i = 0; i \u003c matrix.Rows; i++) { for (int j = 0; j \u003c matrix.Columns; j++) { bool tryFormatSucceeded = matrix[i, j].TryFormat(destination[charsWrittenSoFar..], out var tryFormatCharsWritten, format, provider); charsWrittenSoFar += tryFormatCharsWritten; if (!tryFormatSucceeded) { charsWritten = charsWrittenSoFar; return false; } if (j \u003c matrix.Columns - 1) { if (destination.Length \u003c charsWrittenSoFar + 2) { charsWritten = charsWrittenSoFar; return false; } destination[charsWrittenSoFar++] = elementSeparator; destination[charsWrittenSoFar++] = ' '; } } if (i \u003c matrix.Rows - 1) { if (destination.Length \u003c char","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:4","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Beyond standard number types So far we‚Äôve assumed (quite correctly) that only types that implement INumberBase\u003cTNumber\u003e interface are built‚Äëin system number types. Let‚Äôs quickly implement a rational/fraction structure and see how it can be used in our matrix. For brevity I‚Äôm only providing/implementing formatting routines (stay tuned for more functionality): public readonly record struct Rational\u003cTNumber\u003e(TNumber Numerator, TNumber Denominator) : IEquatable\u003cRational\u003cTNumber\u003e\u003e, IComparisonOperators\u003cRational\u003cTNumber\u003e, Rational\u003cTNumber\u003e, bool\u003e, INumberBase\u003cRational\u003cTNumber\u003e\u003e where TNumber : IBinaryInteger\u003cTNumber\u003e //make sense to allow only integers for numerator and denominator { public static Rational\u003cTNumber\u003e Zero =\u003e new(TNumber.Zero, TNumber.One); public static Rational\u003cTNumber\u003e One =\u003e new(TNumber.One, TNumber.One); public static Rational\u003cTNumber\u003e AdditiveIdentity =\u003e Zero; public static Rational\u003cTNumber\u003e MultiplicativeIdentity =\u003e One; public static int Radix =\u003e TNumber.Radix; public Rational() : this(TNumber.Zero, TNumber.One) { } public Rational\u003cTNumber\u003e Simplify() { var (num, denom) = this; int signNum = TNumber.Sign(num), signDenom = TNumber.Sign(denom); if (signDenom \u003c 0 \u0026\u0026 (signNum \u003c 0 || signNum \u003e 0)) { num = -num; denom = -denom; } if (num == TNumber.Zero || num == TNumber.One || num == -TNumber.One) return this; var gcd = GreatestCommonDivisor(num, denom); return gcd \u003e TNumber.One ? new Rational\u003cTNumber\u003e(num / gcd, denom / gcd) : this; } private static TNumber GreatestCommonDivisor(TNumber a, TNumber b) =\u003e b == TNumber.Zero ? a : GreatestCommonDivisor(b, a % b); private static readonly string TopDigits = \"‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ\"; private static readonly string BottomDigits = \"‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ\"; private static readonly char TopMinus = '‚Åª'; private static readonly char BottomMinus = '‚Çã'; private static readonly char Divider = '‚ÅÑ'; public bool TryFormat(Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format, IFormatProvider? provider) { var (num, denom) = this; int signNum = TNumber.Sign(num), signDenom = TNumber.Sign(denom); if (signDenom \u003c 0 \u0026\u0026 (signNum \u003c 0 || signNum \u003e 0)) { num = -num; denom = -denom; } provider ??= CultureInfo.InvariantCulture; charsWritten = 0; if (destination.Length \u003c 3) return false; bool tryFormatSucceeded = num.TryFormat(destination, out var tryFormatCharsWritten, format, provider); charsWritten += tryFormatCharsWritten; if (!tryFormatSucceeded || destination.Length \u003c charsWritten + 2) return false; var numBlock = destination[..charsWritten]; for (int i = 0; i \u003c numBlock.Length; i++) { var c = numBlock[i]; if (!IsSimpleDigit(c) \u0026\u0026 c != '-') return false; numBlock[i] = c == '-' ? TopMinus : TopDigits[c - '0']; } if (destination.Length \u003c charsWritten + 2) return false; destination[charsWritten++] = Divider; tryFormatSucceeded = denom.TryFormat(destination[charsWritten..], out tryFormatCharsWritten, format, provider); var startOfDenomBlock = charsWritten; charsWritten += tryFormatCharsWritten; if (!tryFormatSucceeded) return false; var denomBlock = destination.Slice(startOfDenomBlock, tryFormatCharsWritten); for (int i = 0; i \u003c denomBlock.Length; i++) { var c = denomBlock[i]; if (!IsSimpleDigit(c) \u0026\u0026 c != '-') return false; denomBlock[i] = c == '-' ? BottomMinus : BottomDigits[c - '0']; } return true; static bool IsSimpleDigit(char c) =\u003e (uint)c \u003c 128 \u0026\u0026 (uint)(c - '0') \u003c= '9' - '0'; } public string ToString(string? format, IFormatProvider? formatProvider) =\u003e this.FormatToString(format, formatProvider); public override string? ToString() =\u003e ToString(\"G\", null); /*... remaining code omitted for brevity*/ } Now we can use Rational structure in our matrix: var rationalMatrix = new Matrix\u003cRational\u003cint\u003e\u003e( Enumerable.Range(1, 9).Select(i =\u003e new Rational\u003cint\u003e( i * 10 * (i % 2 == 0 ? 1 : -1), //-------------------------------- i * 123 )) .ToArray(), 3); //formatting of matrix delegates element formatting to Rational struct var text = rationalMatrix.ToString(); This will produce the following output: ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:7:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Performance Code ‚Äúperformance‚Äù is ambiguous term. It may refer to both ease/speed of development of given feature or how said feature behaves during program runtime. Let me address the former one first as it may be easier to demonstrate ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Speed of development Some time ago I‚Äôve create generic predictor that used logistic regression. In that context ‚Äúgeneric‚Äù meant that it was not dedicated and could be used to solve any binary classification problem (while being universal enough that same mechanism might be employed for multi-class classification). I decided to introduce generic math to this predictor as users may then opt to use, say, different floating point number type (likeSystem.SingleorSystem.Half) when it will give them similar results (for certain problems this really might be the case) but with smaller memory footprint and faster processing times. All that conversion was done on separate branch. One can observe that merely a few changes needed to be applied. Conversion took me not more than 5 minutes. Had this coding be done with generic math in mind from the beginning - impact would have probably been even more negligible - provided that generic math is a concept known by developer (learning curve tends to be steep here) ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:1","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Runtime performance Have a look at my proposal of a simple vector structures. Among them you will find dedicated version for LongVector (not embedded here for brevity) and dedicated version for System.Double: Below you will find version that uses generic math along with version that uses generic math in tandem with pointer arithmetics (Vector2.cs and others were not embedded for brevity): Results These are the results from my machine: Category: Double Method Size Mean [Œºs] Error [Œºs] StdDev [Œºs] Ratio DoubleBench 100 8.387 0.0545 0.0455 1.00 Vector1_Double 100 8.462 0.0117 0.0104 1.01 Vector2_Double 100 7.428 0.0167 0.0148 0.89 Span_Double 100 7.687 0.0216 0.0191 0.92 DoubleBench 10000 935.063 1.4331 1.2704 1.00 Vector1_Double 10000 935.315 2.0107 1.6790 1.00 Vector2_Double 10000 935.157 2.0961 1.8581 1.00 Span_Double 10000 934.439 2.0086 1.7805 1.00 Category: Long Method Size Mean [Œºs] Error [Œºs] StdDev [Œºs] Ratio LongBench 100 4.712 0.0371 0.0347 1.00 Vector1_Long 100 5.616 0.0367 0.0306 1.19 Vector2_Long 100 5.567 0.0105 0.0093 1.18 Span_Long 100 4.583 0.0230 0.0192 0.97 LongBench 10000 430.674 2.0188 1.6858 1.00 Vector1_Long 10000 401.085 2.8027 2.4845 0.93 Vector2_Long 10000 443.050 2.1181 1.8776 1.03 Span_Long 10000 393.092 2.3554 1.9669 0.91 One can clearly see that memory-wise, they all behave the same - by not allocating anything. Types in benchmark were defined as structs. While it may not be best option for such data structures, it helps here by not obstructing our view with needless allocations). Double benchmarks are always ~2 times slower than Long ones but that has nothing to do with generic math itself - floating-point related operations are generally slower on CPUs. What also can be observed is that difference in processing speed is negligible. Generic math is not adding much. In case we need to optimize, we can do so by employing pointer arithmetics or (better yet) - Spans. One could argue that DoubleVectorand LongVector could also benefit from using additional optimization techniques but we need to repeat them for each and every case. We might probably be more tempted to introduce optimizations when many (generic) types can benefit from these actions. This graph summarizes in details all benchmarks performed for System.Long type for various vector sizes. One can clearly see that differences are almost negligible Same data, but restricted only to largest sizes: Source code Full benchmark and results can be found under this gist ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:2","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Summary We‚Äôve seen how one might go about implementing generic math in their code. This matrix is not complete but quite soon I intend to finish it. It will be distributed via nuget like my other packages. Are you still not convinced? It seems that Microsoft is already using generic math in their libraries i.e. in many places in LINQ including (but not limited to) Average or Sum, which replaced some old and seasoned dedicated types copy-and-paste method implementations. If Microsoft is having faith in generic math, there is no reason that shouldn‚Äôt you. ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:9:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Bonus - physics This should be treated as a work-in-progress but have a look at my initial proposal on how units can now be defined in C#: Generic Units ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:10:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"Sources Generic Matrix code Nemesis.TextParsers was used to provide a nice and performant equivalent to string.Split for ReadOnlySpan\u003cchar\u003e for parsing purposes ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:11:0","tags":["language","math","generics","csharp"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["programming"],"content":"C# 8.0 gave us default interface methods. They brought us, among other things, the way to introduce new API members without breaking current contracts. Interfaces however still lacked a ability to model ‚Äústatic‚Äù members out-of-the-box. Factories became our usual way of dealing with object creation but how about functionalities that class itself knows best how to handle. What about, say, parsing? Enter C# 11‚Äôs Static Interface Members (SIM) ","date":"2022-11-17","objectID":"/posts/static-interface-members/:0:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Parsing Let‚Äôs examine the following example: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); } First that strikes to mind is ‚Äúwhat do we need such generic guard here?‚Äù. Read more on Curiously Recurring Generic Pattern. CRGP It get‚Äôs a little tricky to use Curiously Recurring Generic Pattern correctly to the point that even special syntax was proposed for it but none of these proposals were championed. For now, do not worry about it, just do not copy and paste such code like there is no tomorrow. Rest of the example seems reasonable - this states that types implementing this interface must also contain static Parse method. This method can be used inside interface itself: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); //provide implementation in implementing types // this member does not seem to benefit much from being override-able // so \"virtual\" modifier is omitted intentionally static TSelf InvariantParse(ReadOnlySpan\u003cchar\u003e s) =\u003e TSelf.Parse(s, CultureInfo.InvariantCulture); //provide standard *Parse methods implementation static virtual TSelf Parse(string s, IFormatProvider? provider) =\u003e TSelf.Parse(s.AsSpan(), provider); static virtual bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { result = default; if (s == null) return false; try { result = TSelf.Parse(s.AsSpan(), provider); return true; } catch (Exception) { return false; } } static virtual bool TryParse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { try { result = TSelf.Parse(s, provider); return true; } catch (Exception) { result = default; return false; } } } Let‚Äôs implement a simple class that will encapsulate notion of words that can be serialized in string separated with commas record CommaSeparatedWords(IReadOnlyList\u003cstring\u003e Words) : IMyParsable\u003cCommaSeparatedWords\u003e { public static CommaSeparatedWords Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider) { var words = new List\u003cstring\u003e(); foreach (var word in s.Split(',')) words.Add(word.ToString()); return new(words); } public override string ToString() =\u003e string.Join(\",\", Words); } CommaSeparatedWords record will have other Parse and TryParse methods but calling them directly will not be possible i.e. CommaSeparatedWords.TryParse(...). So how can one effectively use them? Answer remains in generic guards. static class MyParsableHelper { public static T ParseAs\u003cT\u003e(this string text, IFormatProvider? provider = null) where T : IMyParsable\u003cT\u003e =\u003e T.Parse(text, provider); } //usage: var words = \"A,B,C\".ParseAs\u003cCommaSeparatedWords\u003e(); But more probably this feature is more useful when wrapped in a class that delegates appropriate functionality. This class will parse line contents while delegating line parsing to CommaSeparatedWords: record Lines\u003cT\u003e(IReadOnlyList\u003cT\u003e Values) : IMyParsable\u003cLines\u003cT\u003e\u003e where T : IMyParsable\u003cT\u003e { public static Lines\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); //this also works in this context //var canParse = T.TryParse(\"\", provider, out var result); return new(lines); } public override string ToString() =\u003e string.Join(Environment.NewLine, Values); } So the following code will properly parse var parsedLines = Lines\u003cCommaSeparatedWords\u003e.Parse(\"\"\" Ala,has,a,cat Cat,has,Ala \"\"\"); as can be seen here: ","date":"2022-11-17","objectID":"/posts/static-interface-members/:1:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Generic math operations Let‚Äôs consider the following example interface IAdditionOperation\u003cT\u003e where T : IAdditionOperation\u003cT\u003e { static abstract T Zero { get; } static abstract T operator +(T lhs, T rhs); } record struct IntWrapper(int Value) : IAdditionOperation\u003cIntWrapper\u003e { public static IntWrapper Zero =\u003e new(0); public static IntWrapper operator +(IntWrapper lhs, IntWrapper rhs) =\u003e new(lhs.Value + rhs.Value); } //we can now write universal \"sum\" method for all IAdditionOperation\u003cT\u003e static T Sum\u003cT\u003e(IEnumerable\u003cT\u003e numbers) where T : IAdditionOperation\u003cT\u003e { var sum = T.Zero; foreach (var number in numbers) sum += number; return sum; //or: //return numbers.Aggregate(T.Zero, (acc, current) =\u003e acc + current); } //which can be used: var sum = Sum(Enumerable.Range(1, 10).Select(i =\u003e new IntWrapper(i))); We could easily create other number wrappers now (for float, long etc.) but that would be pointless. While this example is great for demonstration, one could argue that, in order for it to work, such generic interfaces should be built into .NET number type system. They are. In next post we will explore these concepts. ","date":"2022-11-17","objectID":"/posts/static-interface-members/:2:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Static polymorphism Distinction between shadowed and ‚Äúnew‚Äù overrides for instance members existed in C# practically since it‚Äôs inception. Let‚Äôs examine how it‚Äôs defined for static members interface IValues { static abstract string Static { get; } string Instance { get; } } class Base : IValues { public static string Static =\u003e \"Base\"; public string Instance =\u003e \"Base\"; } //this class shadows members class ShadowImpl : Base, IValues { public static string Static =\u003e \"Shadow\"; public string Instance =\u003e \"Shadow\"; } //this class defines \"new\" overrides class NewImpl : Base, IValues { public static new string Static =\u003e \"New\"; public new string Instance =\u003e \"New\"; } //we can now use generic method to print values static void Print\u003cT\u003e(T t) where T : IValues =\u003e Console.WriteLine(\"{0,6}, {1,6}\", T.Static, t.Instance); //and these are our results var @base = new Base(); var shadow = new ShadowImpl(); var @new = new NewImpl(); Base shadowAsBase = shadow; Base newAsBase = @new; Print(@base); // Base, Base Print(shadow); // Shadow, Shadow Print(@new); // New, New Print(shadowAsBase);// Base, Shadow Print(newAsBase); // Base, New So these examples show that we have static polymorphism in C# now üíñ. Whether you need that it‚Äôs up to you but I wonder when such concepts will find their ways into job interviews üòÄ ","date":"2022-11-17","objectID":"/posts/static-interface-members/:3:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"SIM in standard library ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Parsing One can assume that parsing is such important feature that appropriate interface should exist in standard library. It does, in 2 flavours in fact: IParsable ISpanParsable with later obviously extending the former. One can check, but most, if not all (with notable exception of bool), common types like int, float, byte already implement both of these interfaces. This in turn allows us to use them a generic guards to implement a CSV parser for lines with 3 constituents and a class that will store/parse whole CSV file: readonly record struct CsvLine\u003cT1, T2, T3\u003e(T1 Item1, T2 Item2, T3 Item3) : ISpanParsable\u003cCsvLine\u003cT1, T2, T3\u003e\u003e where T1 : ISpanParsable\u003cT1\u003e where T2 : ISpanParsable\u003cT2\u003e where T3 : ISpanParsable\u003cT3\u003e { public static CsvLine\u003cT1, T2, T3\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { // For some reasons ReadOnlySpan\u003cchar\u003e does not possess a string.Split() equivalent. // This example uses the SpanSplit approach from: // https://www.nuget.org/packages/Nemesis.TextParsers/ var enumerator = s.Split(',').GetEnumerator(); if (!enumerator.MoveNext()) throw new(\"No element at 1st position\"); var t1 = T1.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 2nd position\"); var t2 = T2.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 3rd position\"); var t3 = T3.Parse(enumerator.Current, CultureInfo.InvariantCulture); return new(t1, t2, t3); } //remaining Parse methods omitted for brevity } record CsvFile\u003cT\u003e(IReadOnlyList\u003cT\u003e Lines) : ISpanParsable\u003cCsvFile\u003cT\u003e\u003e where T : ISpanParsable\u003cT\u003e { public static CsvFile\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); return new(lines); } //remaining Parse methods omitted for brevity } This will allow parsing to be done in following fashion: var parsedNumbers = CsvFile\u003cint\u003e.Parse(\"\"\" 11 22 33 \"\"\"); //or more advanced example var parsedStructs = CsvFile\u003cCsvLine\u003cint, float, char\u003e\u003e.Parse(\"\"\" 11,1.1,A 22,2.2,B 33,3.3,C \"\"\"); ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:1","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Generic math operation This topic is quite comprehensive. Stay tuned for a separate blog post. It‚Äôs scheduled for 5th of December 2022. We will attempt to implement whole generic type using new constructs ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:2","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["programming"],"content":"Sources Static Interface Members ","date":"2022-11-17","objectID":"/posts/static-interface-members/:5:0","tags":["architecture","interface","csharp"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["blog"],"content":"This post serves as my notebook for using Font Awesome icons on this blog (or any other rendered by Hugo engine). Get aclassfrom Font Awesome website and use it as follows :(fa-solid fa-house): :(fas fa-clock): which renders as ¬† ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:0:0","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"Sizing FA provides list of standard sizes. Not only do these classes scale icons up or down but also provide appropriate vertical alignment. The following is the list of standard relative sizes provided by the library Size Font Size Equivalent in Pixels Example fa-2xs 0.625em 10px fa-xs 0.75em 12px fa-sm 0.875em 14px fa-lg 1.25em 20px fa-xl 1.5em 24px fa-2xl 2em 32px In addition to relative sizes, also literal sizes are available Literal Sizing Class Font Size Example fa-1x 1em fa-2x 2em fa-3x 3em fa-4x 4em fa-5x 5em fa-6x 6em fa-7x 7em fa-8x 8em fa-9x 9em fa-10x 10em ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:1:0","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"Animation There are couple of animations built-in FA library. For more info follow here ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:2:0","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"Beat animation Beat animation allows to draw attentions to a ‚Äúliving‚Äù object. Employfa-beatto use it :(fa-solid fa-heart fa-beat): :(fa-solid fa-clock fa-beat): which renders as ¬† In order to obtain more control on animation one must use HTML syntax \u003cdiv class=\"fa-3x\"\u003e \u003ci class=\"fa-solid fa-circle-plus fa-beat\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-heart fa-beat\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-heart fa-beat\" style=\"--fa-animation-duration: 0.5s;\" \u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-heart fa-beat\" style=\"--fa-animation-duration: 2s;\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-heart fa-beat\" style=\"--fa-beat-scale: 2.0;\"\u003e\u003c/i\u003e \u003c/div\u003e ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:2:1","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"Spin animation One of the most useful animations is a spin effect that is wrapped infa-spinclass: :(fa-solid fa-sync fa-spin): :(fa-solid fa-circle-notch fa-spin): which render as ¬† More advanced examples can be obtained as follows \u003cdiv class=\"fa-3x\"\u003e \u003ci class=\"fa-solid fa-sync fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-circle-notch fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-cog fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-cog fa-spin fa-spin-reverse\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-spinner fa-spin-pulse\"\u003e\u003c/i\u003e \u003ci class=\"fa-solid fa-spinner fa-spin-pulse fa-spin-reverse\"\u003e\u003c/i\u003e \u003c/div\u003e ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:2:2","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"List of free icons Icon Name Icon Name Icon Name 500px accessible-icon accusoft address-book address-book address-card address-card adjust adn adversal affiliatetheme air-freshener algolia align-center align-justify align-left align-right amazon ambulance american-sign-language-interpreting amilia anchor android angellist angle-double-down angle-double-left angle-double-right angle-double-up angle-down angle-left angle-right angle-up angrycreative angular app-store app-store-ios apper apple apple-pay archive arrow-alt-circle-down arrow-alt-circle-down arrow-alt-circle-left arrow-alt-circle-left arrow-alt-circle-right arrow-alt-circle-right arrow-alt-circle-up arrow-alt-circle-up arrow-circle-down arrow-circle-left arrow-circle-right arrow-circle-up arrow-down arrow-left arrow-right arrow-up arrows-alt arrows-alt-h arrows-alt-v assistive-listening-systems asterisk asymmetrik at audible audio-description autoprefixer avianex aviato aws backward balance-scale ban bandcamp barcode bars bath battery-empty battery-full battery-half battery-quarter battery-three-quarters bed beer behance behance-square bell bell bell-slash bell-slash bicycle bimobject binoculars birthday-cake bitbucket bitcoin bity black-tie blackberry blind blogger blogger-b bluetooth bluetooth-b bold bolt bomb book bookmark bookmark braille briefcase btc bug building building bullhorn bullseye buromobelexperte bus buysellads calculator calendar calendar calendar-alt calendar-alt calendar-check calendar-check calendar-minus calendar-minus calendar-plus calendar-plus calendar-times calendar-times camera camera-retro car caret-down caret-left caret-right caret-square-down caret-square-down caret-square-left caret-square-left caret-square-right caret-square-right caret-square-up caret-square-up caret-up cart-arrow-down cart-plus cc-amex cc-apple-pay cc-diners-club cc-discover cc-jcb cc-mastercard cc-paypal cc-stripe cc-visa centercode certificate chart-area chart-bar chart-bar chart-line chart-pie check check-circle check-circle check-square check-square chevron-circle-down chevron-circle-left chevron-circle-right chevron-circle-up chevron-down chevron-left chevron-right chevron-up child chrome circle circle circle-notch clipboard clipboard clock clock clone clone closed-captioning closed-captioning cloud cloud-download-alt cloud-upload-alt cloudscale cloudsmith cloudversify code code-branch codepen codiepie coffee cog cogs columns comment comment comment-alt comment-alt comments comments compass compass compress connectdevelop contao copy copy copyright copyright cpanel creative-commons credit-card credit-card crop crosshairs css3 css3-alt cube cubes cut cuttlefish d-and-d dashcube database deaf delicious deploydog deskpro desktop deviantart digg digital-ocean discord discourse dochub docker dollar-sign dot-circle dot-circle download draft2digital dribbble dribbble-square dropbox drupal dyalog earlybirds edge edit edit eject ellipsis-h ellipsis-v ember empire envelope envelope envelope-open envelope-open envelope-square envira eraser erlang etsy euro-sign exchange-alt exclamation exclamation-circle exclamation-triangle expand expand-arrows-alt expeditedssl external-link-alt external-link-square-alt eye eye-dropper eye-slash eye-slash facebook facebook-f facebook-messenger facebook-square fast-backward fast-forward fax female fighter-jet file file file-alt file-alt file-archive file-archive file-audio file-audio file-code file-code file-excel file-excel file-image file-image file-pdf file-pdf file-powerpoint file-powerpoint file-video file-video file-word file-word film filter fire fire-extinguisher firefox first-order firstdraft flag flag flag-checkered flask flickr fly folder folder folder-open folder-open font font-awesome font-awesome-alt font-awesome-flag fonticons fonticons-fi fort-awesome fort-awesome-alt forumbee forward foursquare free-code-camp freebsd frown frown futbol futbol gamepad gavel gem gem genderless get-pocket gg gg-circle gift git git-square githu","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:3:0","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["blog"],"content":"Sources FontAwesome free icons list generator ","date":"2022-10-05","objectID":"/posts/font-awesome-cheatsheet/:4:0","tags":["icons","FontAwesome"],"title":"Font Awesome Cheatsheet","uri":"/posts/font-awesome-cheatsheet/"},{"categories":["programming"],"content":"Recently we‚Äôve been seeing an increased activities on various blogs due to upcoming .NET 5 release date and one of it‚Äôs hottest feature - C# 9.0 records. A lot was written about this feature, starting with MSDN. What was not clear however, was whether one can use records in older frameworks - like .NET 4.8. Tip To be able to run all of following examples to the fullest extent, make sure your language version is set to 9.0 or larger (i.e. in *.csproj file) \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:0:0","tags":["records","legacy","csharp"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["programming"],"content":"Anatomy of record positional properties Let‚Äôs settle our attention on the following example record Vertebrate(string Name) { public Vertebrate() : this(\"\") { } } public enum Habitat { Terrestrial, Aquatic, Amphibian } public record Reptile(Habitat Habitat) : Vertebrate { } Upon compilation under net5.0 framework moniker, everything works as expected. Change it to however to net48 and you will not be able to compile it. This compiler feature fortunatelly works like opt-in member resolution (similarly to string interpolation). What compiler needs in this case is an accessible class of the following structure so that init-only properties are accessible //TODO: use appropriate compiler directives for legacy targets - it's not needed in net5.0+ #if NETSTANDARD2_0 namespace System.Runtime.CompilerServices { [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] internal static class IsExternalInit { } } #endif ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:0","tags":["records","legacy","csharp"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["programming"],"content":"Check if property is init-only After quick research one can spot that init-only setter has special structure: .set instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) DotnetCommunityDemoNet5.Records/Vertebrate::set_Name(string) To determine that setter is init-only one just needs to query the existence of required modifier initialized with aforementioned IsExternalInit type - this code helper should do the trick: public static class RecordsHelper { public static bool IsInitOnly(this PropertyInfo property) =\u003e property.CanWrite \u0026\u0026 property.SetMethod is var setter \u0026\u0026 setter.ReturnParameter.GetRequiredCustomModifiers() is var reqMods \u0026\u0026 reqMods.Length \u003e 0 \u0026\u0026 Array.IndexOf(reqMods, typeof(System.Runtime.CompilerServices.IsExternalInit)) \u003e -1; } ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:1","tags":["records","legacy","csharp"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["programming"],"content":"Consuming records in older frameworks Tip Records are not any special types - they are, per se, not specially recognized by CLI/CLR. They are just specially designed classes with: init only properties (default behavior for positional records) automatic structural equality, IEquatable\u003c\u003e implementation, equality operators positional deconstruction printing/formatting Due to this phenomenon, consuming records is quite straightforward - you are using them as normal classes. So even older C# versions will be able to use it straight away. If you‚Äôd like to use with keyword then you need to use C# 9.0+ for instance by specifying that in *.csproj file of your target project: \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e and you‚Äôll be able to use all record features upon consumption: ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:2:0","tags":["records","legacy","csharp"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["programming"],"content":"Sources Records producer/consumer ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:3:0","tags":["records","legacy","csharp"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":null,"content":"Micha≈Ç Bry≈Çka Managing software developer, tech lead. Interested in systems design and normalization with performance as his priority. Experienced in smart client applications development, compiler writing, optimization, algorithmics. Clean code advocate, performance enthusiast, .Net freak Specialties: .Net (especially C# and VB.Net) Kotlin databases (MS SQL Server, Oracle) server-side technologies (ASP.Net) #compilerIsSexy #highPerf #Roslyn #superFast #SIMD ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]