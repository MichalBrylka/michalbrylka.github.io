[{"categories":["csharp"],"content":"C# 11.0 generic math is very powerful extension to already capable generic types system present in C# since version 2.0. Besides static interface members there are couple of changes that make it easier to express math concepts in C#. Let‚Äôs see what needed to change in order to add this neat feature. Note This blog post participates in C# Advent Calendar 2022. Expect around 50 awesome posts this month, with 2 being revealed every day. It‚Äôs digital/C#-oriented counterpart of old German tradition ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:0:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Interfaces and operations While generic math is C# 11 feature, there were some new additions in .NET framework itself. In order to facilitate appropriate abstraction, the following interfaces were introduced and numeric/built-in types subsequently started implementing them: Interface Description INumberBase Base interface for all numbers INumber All members related to numbers. Extends INumberBase mostly for comparison operations IParseable Parse(string, IFormatProvider) ISpanParseable Parse(ReadOnlySpan, IFormatProvider) IAdditionOperators x + y IBitwiseOperators x \u0026 y, x | y, x ^ y and ~x IComparisonOperators x \u003c y, x \u003e y, x \u003c= y, and x \u003e= y IDecrementOperators ‚Äìx and x‚Äì IDivisionOperators x / y IEqualityOperators x == y and x != y IIncrementOperators ++x and x++ IModulusOperators x % y IMultiplyOperators x * y IShiftOperators x ¬´ y and x ¬ª y ISubtractionOperators x - y IUnaryNegationOperators -x IUnaryPlusOperators +x IAdditiveIdentity (x + T.AdditiveIdentity) == x IMinMaxValue T.MinValue and T.MaxValue IMultiplicativeIdentity (x * T.MultiplicativeIdentity) == x IBinaryFloatingPoint Members common to binary floating-point types IBinaryInteger Members common to binary integer types IBinaryNumber Members common to binary number types IFloatingPoint Members common to floating-point types INumber Members common to number types ISignedNumber Members common to signed number types IUnsignedNumber Members common to unsigned number types List of all of them can be found on MSDN ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:1:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Checked operators In C# 11 it is now possible to specify operators as checked. Compiler will select appropriate version depending on context (Visual Studio will navigate to appropriate operator definition upon pressing /‚ÄúGo to definition‚Äù). Let‚Äôs see that on example: readonly record struct Point(int X, int Y) { public static Point operator checked +(Point left, Point right) =\u003e checked(new(left.X + right.X, left.Y + right.Y)); public static Point operator +(Point left, Point right) =\u003e new(left.X + right.X, left.Y + right.Y); } //usage var point = new Point(int.MaxValue - 1, int.MaxValue - 2); //Point { X = 2147483646, Y = 2147483645 } var @unchecked = unchecked(point + point); //Point { X = -4, Y = -6 } var @checked = checked(point + point); //‚ö†Ô∏è throws System.OverflowException ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:2:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Identity element and constants Every number type usually (always for C# numbers but that is not necessarily the case in math) has some identity elements for most popular operations (addition and multiplication). The following listing demonstrates them using generic guard as these constants are not publicly exposed private static void Constants\u003cT\u003e() where T : INumber\u003cT\u003e { var one = T.One; var zero = T.Zero; var additiveIdentity = T.AdditiveIdentity; var multiplicativeIdentity = T.MultiplicativeIdentity; } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:3:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Conversions In order to be able to smoothly convert numbers from other number types, several methods were added: CreateChecked - convert ‚Äúexactly‚Äù or throw if number falls outside the representable range CreateSaturating - convert values saturating any values that fall outside the representable range CreateTruncating - convert values truncating any values that fall outside the representable range //specifying generic type is not needed, it's just here for clarity var b1 = byte.CreateSaturating\u003cint\u003e(300); //255 var b2 = byte.CreateTruncating(300); //44 var b3 = byte.CreateChecked(300); //‚ö†Ô∏è Arithmetic operation resulted in an overflow. var b4 = byte.CreateChecked(3.14); //3 ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:4:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Dedicated functions New function were introduced to built-in types to facilitate typical operation that we perform with given number groups. //Check if integer is power of two. Equivalent to BitOperations.IsPow2(1024) var isPow = int.IsPow2(1024); // true //Population count (number of bits set). Same as BitOperations.PopCount(15) - vectorized if possible var pop = int.PopCount(15); // 4 //Cubic root of a specified number. Equivalent to MathF.Cbrt(x) var cbrt = float.Cbrt(8.0f); // 2 //Sine of the specified angle (in radians). Equivalent to MathF.Sin(x) var sin = float.Sin(float.Pi / 6.0f); //0.5 For more functions see list for integers or floating point numbers. Other interesting function groups are: ITrigonometricFunctions IRootFunctions IPowerFunctions ILogarithmicFunctions ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:5:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Matrix definition We are now ready to propose a new type that will denote a generic matrix of number-like structures. Make sure to read a post about static interface members if that concept is still new to you. ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Structure Let‚Äôs start with simple definition. Just for fun we will be restricting our number generic parameter to unmanaged types. This is not strictly needed for our example but it will allow for some tricks like faster array enumeration public partial class Matrix\u003cTNumber\u003e //for now we are not extending any interface where TNumber : unmanaged //needed for pointer \"magic\" { private readonly TNumber[,] _data; public int Rows { get; } public int Columns { get; } public int Size { get; } public TNumber this[int iRow, int iCol] =\u003e _data[iRow, iCol]; public Matrix(TNumber[,] data) { _data = data; Rows = data.GetLength(0); Columns = data.GetLength(1); Size = Rows * Columns; } //optionally we'd like to be able to create Matrix using 1-D array with certain number of columns public unsafe Matrix(TNumber[] data, int columns) { var data2d = new TNumber[data.Length / columns, columns]; fixed (TNumber* pSource = data, pTarget = data2d) { for (int i = 0; i \u003c data.Length; i++) pTarget[i] = pSource[i]; } _data = data2d; Rows = data2d.GetLength(0); Columns = data2d.GetLength(1); } } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:1","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Matrix operations While this class already is able to store some data, we would not be able to do anything meaningful with it. Let‚Äôs add our first math operation - addition. Since that operation uses only addition and needs to be seeded with zero (additive identity) we could modify our generic guard to: class Matrix where TNumber : unmanaged, IAdditionOperators\u003cTNumber, TNumber, TNumber\u003e, IAdditiveIdentity\u003cTNumber, TNumber\u003e { /*...*/ public unsafe TNumber Sum() { var result = TNumber.AdditiveIdentity; fixed (TNumber* pData = _data) //use pointers to be able to iterate array faster { var p = pData; for (int i = 0; i \u003c Size; i++) result += *p++; } return result; } } but we would be better off when that guard would be changed to public partial class Matrix\u003cTNumber\u003e where TNumber : unmanaged, //it is just necessary to mark number type appropriately to be able to use it in generic contexts INumberBase\u003cTNumber\u003e { /*...*/ public unsafe TNumber Sum() { //\"Zero\" also looks more natural in that context as opposed to \"AdditiveIdentity\" var result = TNumber.Zero; fixed (TNumber* pData = _data) { var p = pData; for (int i = 0; i \u003c Size; i++) result += *p++; } return result; } } Summation is obviously useful but it‚Äôs also trivial in it‚Äôs form. For instance let‚Äôs consider C# whole number types. Like in math, natural and integer numbers are closed under addition. When you consider other operations on these numbers, say division, this is no longer the case. While we could calculate an average of integers in C# as follows var intArray = new[] { 1, 2, 4 }; var avg = intArray.Sum() / intArray.Length; //2 it would be more convenient to convert result and intermediate operations to floating point numbers. Even LINQ function does that: var avgLinq = intArray.Average(); //2.3333333333333335 This conversion will do the trick for our matrix: public unsafe TResult Sum\u003cTResult\u003e() where TResult : INumber\u003cTResult\u003e { var result = TResult.Zero; fixed (TNumber* pData = _data) { var p = pData; for (int i = 0; i \u003c Size; i++) result += TResult.CreateChecked(*p++); } return result; } // now Average can use Sum\u003cTResult\u003e public TResult Average\u003cTResult\u003e() where TResult : INumber\u003cTResult\u003e { TResult sum = Sum\u003cTResult\u003e(); return sum / TResult.CreateChecked(Size); } No matrix is complete without Determinant function. While there are dozens of algorithms to do that, I‚Äôll use a¬†plain decomposition approach due to it‚Äôs simplicity public TNumber Determinant() { if (Rows != Columns) throw new(\"Determinant of a non-square matrix doesn't exist\"); var det = TNumber.Zero; if (Rows == 1) return this[0, 0]; if (Rows == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0]; for (int j = 0; j \u003c Columns; j++) { TNumber reduced = this[0, j] * Minor(0, j).Determinant(); if (j % 2 == 1) reduced = -reduced; det += reduced; } return det; } public Matrix\u003cTNumber\u003e Minor(int iRow, int iCol) { var minor = new TNumber[Rows - 1, Columns - 1]; int m = 0; for (int i = 0; i \u003c Rows; i++) { if (i == iRow) continue; int n = 0; for (int j = 0; j \u003c Columns; j++) { if (j == iCol) continue; minor[m, n] = this[i, j]; n++; } m++; } return new(minor); } Similarly it might be useful to obtain largest and smallest element in matrix. Since that requires some comparisons, let‚Äôs add IComparisonOperators\u003cTNumber, TNumber, bool\u003e interface to our generic guard for TNumber. Doing so enables us to then use comparison operators. We will however lose (as a consequence) the ability of using types that do not possess relational ordering - Complex type being most notable here Note Using IComparisonOperators\u003cTNumber, TNumber, bool\u003e is somewhat limiting. It‚Äôs probably more important to be able to use final matrix with types like Complex especially if Min/Max operation could be added using different approach. So final design of matrix might reflect that notion public unsafe TNumber Min() { if (Size == 0) throw new(\"Matrix is empty\"); TNumber result; fixed (TNumber* pData = _data) { var p = pData; result = *p; for (int ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:2","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Matrix operators Have a look at the following operators (code example might need expanding): //add 2 matrices public unsafe static Matrix\u003cTNumber\u003e operator +(Matrix\u003cTNumber\u003e left, Matrix\u003cTNumber\u003e right) { if (left.Rows != right.Rows || left.Columns != right.Columns) throw new(\"Sum of 2 matrices is only possible when they are same size\"); var data = new TNumber[left.Rows, left.Columns]; var size = left.Rows * left.Columns; fixed (TNumber* lSource = left._data, rSource = right._data, target = data) { for (int i = 0; i \u003c size; i++) target[i] = lSource[i] + rSource[i]; //checked operator version would differ only in this line } return new Matrix\u003cTNumber\u003e(data); } //right-side operator for adding single number element-wise public unsafe static Matrix\u003cTNumber\u003e operator +(Matrix\u003cTNumber\u003e left, TNumber right) { var data = new TNumber[left.Rows, left.Columns]; var size = left.Rows * left.Columns; fixed (TNumber* lSource = left._data, target = data) { for (int i = 0; i \u003c size; i++) target[i] = lSource[i] + right; } return new Matrix\u003cTNumber\u003e(data); } // Multiplication. More efficient function might be chosen for production code. // This is just to illustrate this operator public static Matrix\u003cTNumber\u003e operator *(Matrix\u003cTNumber\u003e a, Matrix\u003cTNumber\u003e b) { int rowsA = a.Rows, colsA = a.Columns, rowsB = b.Rows, colsB = b.Columns; if (colsA != rowsB) throw new(\"Matrixes can't be multiplied\"); var data = new TNumber[rowsA, colsB]; for (int i = 0; i \u003c rowsA; i++) { for (int j = 0; j \u003c colsB; j++) { var temp = TNumber.Zero; for (int k = 0; k \u003c colsA; k++) temp += a[i, k] * b[k, j]; data[i, j] = temp; } } return new Matrix\u003cTNumber\u003e(data); } ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:3","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Parsing No math structure is complete without parsing and formatting routines. We would like to support multiple matrix definition formats like: Matlab: [1,2,3 ; 4,5,6 ; 7,8,9] Mathematica: {{1,2,3},{4,5,6},{7,8,9}} natural notation: The code below might do the trick (full code is linked at the end of current article): /// \u003csummary\u003eParsing and formatting operation for matrices\u003c/summary\u003e public interface IMatrixTextFormat { /// \u003csummary\u003e /// Parse matrix from text buffer /// \u003c/summary\u003e Matrix\u003cTNumber\u003e Parse\u003cTNumber\u003e(ReadOnlySpan\u003cchar\u003e s) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e; /// \u003csummary\u003e /// Attempt to format current matrix in provided text buffer /// \u003c/summary\u003e bool TryFormat\u003cTNumber\u003e(Matrix\u003cTNumber\u003e matrix, Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e; } public readonly struct StandardFormat : IMatrixTextFormat { private readonly IFormatProvider _underlyingProvider; private readonly NumberStyles? _numberStyles; private readonly char _elementSeparator; private static readonly char[] _rowSeparators = Environment.NewLine.ToCharArray(); public StandardFormat() : this(CultureInfo.InvariantCulture) { } public StandardFormat(IFormatProvider? underlyingProvider, NumberStyles numberStyles = NumberStyles.Any) { _numberStyles = numberStyles; _underlyingProvider = underlyingProvider ?? CultureInfo.InvariantCulture; (_underlyingProvider, _elementSeparator) = GetParameters(); } private (IFormatProvider Provider, char ElementSeparator) GetParameters() { var provider = _underlyingProvider ?? CultureInfo.InvariantCulture; char elementSeparator = _elementSeparator != '\\0' ? _elementSeparator : (provider is CultureInfo ci ? ci.TextInfo.ListSeparator.Trim().Single() : ';'); return (provider, elementSeparator); } public Matrix\u003cTNumber\u003e Parse\u003cTNumber\u003e(ReadOnlySpan\u003cchar\u003e s) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e { var (provider, elementSeparator) = GetParameters(); var numberStyles = _numberStyles ?? NumberStyles.Any; var rowsEnumerator = s.Split(_rowSeparators, true).GetEnumerator(); if (!rowsEnumerator.MoveNext()) throw new FormatException(\"Non empty text is expected\"); var firstRow = rowsEnumerator.Current; int numCols = 0; using var buffer = new ValueSequenceBuilder\u003cTNumber\u003e(stackalloc TNumber[32]); foreach (var col in firstRow.Split(elementSeparator, true)) { if (col.IsEmpty) continue; buffer.Append(TNumber.Parse(col, numberStyles, provider)); numCols++; } int numRows = 1; while (rowsEnumerator.MoveNext()) { var row = rowsEnumerator.Current; if (row.IsEmpty) continue; foreach (var col in row.Split(elementSeparator, true)) { if (col.IsEmpty) continue; buffer.Append(TNumber.Parse(col, numberStyles, provider)); } numRows++; } var matrix = new TNumber[numRows, numCols]; buffer.AsSpan().CopyTo2D(matrix); return new Matrix\u003cTNumber\u003e(matrix); } public bool TryFormat\u003cTNumber\u003e(Matrix\u003cTNumber\u003e matrix, Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format) where TNumber : unmanaged, IComparisonOperators\u003cTNumber, TNumber, bool\u003e, INumberBase\u003cTNumber\u003e { var (provider, elementSeparator) = GetParameters(); var newLine = _rowSeparators.AsSpan(); var newLineLen = newLine.Length; int charsWrittenSoFar = 0; for (int i = 0; i \u003c matrix.Rows; i++) { for (int j = 0; j \u003c matrix.Columns; j++) { bool tryFormatSucceeded = matrix[i, j].TryFormat(destination[charsWrittenSoFar..], out var tryFormatCharsWritten, format, provider); charsWrittenSoFar += tryFormatCharsWritten; if (!tryFormatSucceeded) { charsWritten = charsWrittenSoFar; return false; } if (j \u003c matrix.Columns - 1) { if (destination.Length \u003c charsWrittenSoFar + 2) { charsWritten = charsWrittenSoFar; return false; } destination[charsWrittenSoFar++] = elementSeparator; destination[charsWrittenSoFar++] = ' '; } } if (i \u003c matrix.Rows - 1) { if (destination.Length \u003c char","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:6:4","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Beyond standard number types So far we‚Äôve assumed (quite correctly) that only types that implement INumberBase\u003cTNumber\u003e interface are built‚Äëin system number types. Let‚Äôs quickly implement a rational/fraction structure and see how it can be used in our matrix. For brevity I‚Äôm only providing/implementing formatting routines (stay tuned for more functionality): public readonly record struct Rational\u003cTNumber\u003e(TNumber Numerator, TNumber Denominator) : IEquatable\u003cRational\u003cTNumber\u003e\u003e, IComparisonOperators\u003cRational\u003cTNumber\u003e, Rational\u003cTNumber\u003e, bool\u003e, INumberBase\u003cRational\u003cTNumber\u003e\u003e where TNumber : IBinaryInteger\u003cTNumber\u003e //make sense to allow only integers for numerator and denominator { public static Rational\u003cTNumber\u003e Zero =\u003e new(TNumber.Zero, TNumber.One); public static Rational\u003cTNumber\u003e One =\u003e new(TNumber.One, TNumber.One); public static Rational\u003cTNumber\u003e AdditiveIdentity =\u003e Zero; public static Rational\u003cTNumber\u003e MultiplicativeIdentity =\u003e One; public static int Radix =\u003e TNumber.Radix; public Rational() : this(TNumber.Zero, TNumber.One) { } public Rational\u003cTNumber\u003e Simplify() { var (num, denom) = this; int signNum = TNumber.Sign(num), signDenom = TNumber.Sign(denom); if (signDenom \u003c 0 \u0026\u0026 (signNum \u003c 0 || signNum \u003e 0)) { num = -num; denom = -denom; } if (num == TNumber.Zero || num == TNumber.One || num == -TNumber.One) return this; var gcd = GreatestCommonDivisor(num, denom); return gcd \u003e TNumber.One ? new Rational\u003cTNumber\u003e(num / gcd, denom / gcd) : this; } private static TNumber GreatestCommonDivisor(TNumber a, TNumber b) =\u003e b == TNumber.Zero ? a : GreatestCommonDivisor(b, a % b); private static readonly string TopDigits = \"‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ\"; private static readonly string BottomDigits = \"‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ\"; private static readonly char TopMinus = '‚Åª'; private static readonly char BottomMinus = '‚Çã'; private static readonly char Divider = '‚ÅÑ'; public bool TryFormat(Span\u003cchar\u003e destination, out int charsWritten, ReadOnlySpan\u003cchar\u003e format, IFormatProvider? provider) { var (num, denom) = this; int signNum = TNumber.Sign(num), signDenom = TNumber.Sign(denom); if (signDenom \u003c 0 \u0026\u0026 (signNum \u003c 0 || signNum \u003e 0)) { num = -num; denom = -denom; } provider ??= CultureInfo.InvariantCulture; charsWritten = 0; if (destination.Length \u003c 3) return false; bool tryFormatSucceeded = num.TryFormat(destination, out var tryFormatCharsWritten, format, provider); charsWritten += tryFormatCharsWritten; if (!tryFormatSucceeded || destination.Length \u003c charsWritten + 2) return false; var numBlock = destination[..charsWritten]; for (int i = 0; i \u003c numBlock.Length; i++) { var c = numBlock[i]; if (!IsSimpleDigit(c) \u0026\u0026 c != '-') return false; numBlock[i] = c == '-' ? TopMinus : TopDigits[c - '0']; } if (destination.Length \u003c charsWritten + 2) return false; destination[charsWritten++] = Divider; tryFormatSucceeded = denom.TryFormat(destination[charsWritten..], out tryFormatCharsWritten, format, provider); var startOfDenomBlock = charsWritten; charsWritten += tryFormatCharsWritten; if (!tryFormatSucceeded) return false; var denomBlock = destination.Slice(startOfDenomBlock, tryFormatCharsWritten); for (int i = 0; i \u003c denomBlock.Length; i++) { var c = denomBlock[i]; if (!IsSimpleDigit(c) \u0026\u0026 c != '-') return false; denomBlock[i] = c == '-' ? BottomMinus : BottomDigits[c - '0']; } return true; static bool IsSimpleDigit(char c) =\u003e (uint)c \u003c 128 \u0026\u0026 (uint)(c - '0') \u003c= '9' - '0'; } public string ToString(string? format, IFormatProvider? formatProvider) =\u003e this.FormatToString(format, formatProvider); public override string? ToString() =\u003e ToString(\"G\", null); /*... remaining code omitted for brevity*/ } Now we can use Rational structure in our matrix: var rationalMatrix = new Matrix\u003cRational\u003cint\u003e\u003e( Enumerable.Range(1, 9).Select(i =\u003e new Rational\u003cint\u003e( i * 10 * (i % 2 == 0 ? 1 : -1), //-------------------------------- i * 123 )) .ToArray(), 3); //formatting of matrix delegates element formatting to Rational struct var text = rationalMatrix.ToString(); This will produce the following output: ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:7:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Performance Code ‚Äúperformance‚Äù is ambiguous term. It may refer to both ease/speed of development of given feature or how said feature behaves during program runtime. Let me address the former one first as it may be easier to demonstrate ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Speed of development Some time ago I‚Äôve create generic predictor that used logistic regression. In that context ‚Äúgeneric‚Äù meant that it was not dedicated and could be used to solve any binary classification problem (while being universal enough that same mechanism might be employed for multi-class classification). I decided to introduce generic math to this predictor as users may then opt to use, say, different floating point number type (likeSystem.SingleorSystem.Half) when it will give them similar results (for certain problems this really might be the case) but with smaller memory footprint and faster processing times. All that conversion was done on separate branch. One can observe that merely a few changes needed to be applied. Conversion took me not more than 5 minutes. Had this coding be done with generic math in mind from the beginning - impact would have probably been even more negligible - provided that generic math is a concept known by developer (learning curve tends to be steep here) ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:1","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Runtime performance Have a look at my proposal of a simple vector structures. Among them you will find dedicated version for LongVector (not embedded here for brevity) and dedicated version for System.Double: Below you will find version that uses generic math along with version that uses generic math in tandem with pointer arithmetics (Vector2.cs and others were not embedded for brevity): These are the results from my machine: Method Categories Size Mean Error StdDev Ratio DoubleBench Double 100 8.387 us 0.0545 us 0.0455 us 1.00 Vector1_Double Double 100 8.462 us 0.0117 us 0.0104 us 1.01 Vector2_Double Double 100 7.428 us 0.0167 us 0.0148 us 0.89 Span_Double Double 100 7.687 us 0.0216 us 0.0191 us 0.92 DoubleBench Double 10000 935.063 us 1.4331 us 1.2704 us 1.00 Vector1_Double Double 10000 935.315 us 2.0107 us 1.6790 us 1.00 Vector2_Double Double 10000 935.157 us 2.0961 us 1.8581 us 1.00 Span_Double Double 10000 934.439 us 2.0086 us 1.7805 us 1.00 LongBench Long 100 4.712 us 0.0371 us 0.0347 us 1.00 Vector1_Long Long 100 5.616 us 0.0367 us 0.0306 us 1.19 Vector2_Long Long 100 5.567 us 0.0105 us 0.0093 us 1.18 Span_Long Long 100 4.583 us 0.0230 us 0.0192 us 0.97 LongBench Long 10000 430.674 us 2.0188 us 1.6858 us 1.00 Vector1_Long Long 10000 401.085 us 2.8027 us 2.4845 us 0.93 Vector2_Long Long 10000 443.050 us 2.1181 us 1.8776 us 1.03 Span_Long Long 10000 393.092 us 2.3554 us 1.9669 us 0.91 One can clearly see that memory-wise, they all behave the same - by not allocating anything. Types in benchmark were defined as structs. While it may not be best option for such data structures, it helps here by not obstructing our view with needless allocations). Double benchmarks are always ~2 times slower than Long ones but that has nothing to do with generic math itself - floating-point related operations are generally slower on CPUs. What also can be observed is that difference in processing speed is negligible. Generic math is not adding much. In case we need to optimize, we can do so by employing pointer arithmetics or (better yet) - Spans. One could argue that DoubleVectorand LongVector could also benefit from using additional optimization techniques but we need to repeat them for each and every case. We might probably be more tempted to introduce optimizations when many (generic) types can benefit from these actions. Source code Full benchmark and results can be found under this gist ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:8:2","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Summary We‚Äôve seen how one might go about implementing generic math in their code. This matrix is not complete but quite soon I intend to finish it. It will be distributed via nuget like my other packages ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:9:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Bonus - physics This should be treated as a work-in-progress but have a look at my initial proposal on how units can now be defined in C#: Generic Units ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:10:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"Sources Generic Matrix code ","date":"2022-12-05","objectID":"/posts/generic-math-matrix/:11:0","tags":["language","math","generics"],"title":"Generic math extended example","uri":"/posts/generic-math-matrix/"},{"categories":["csharp"],"content":"C# 8.0 gave us default interface methods. They brought us, among other things, the way to introduce new API members without breaking current contracts. Interfaces however still lacked a ability to model ‚Äústatic‚Äù members out-of-the-box. Factories became our usual way of dealing with object creation but how about functionalities that class itself knows best how to handle. What about, say, parsing? Enter C# 11‚Äôs Static Interface Members (SIM) ","date":"2022-11-17","objectID":"/posts/static-interface-members/:0:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Parsing Let‚Äôs examine the following example: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); } First that strikes to mind is ‚Äúwhat do we need such generic guard here?‚Äù. Read more on Curiously Recurring Generic Pattern. CRGP It get‚Äôs a little tricky to use Curiously Recurring Generic Pattern correctly to the point that even special syntax was proposed for it but none of these proposals were championed. For now, do not worry about it, just do not copy and paste such code like there is no tomorrow. Rest of the example seems reasonable - this states that types implementing this interface must also contain static Parse method. This method can be used inside interface itself: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); //provide implementation in implementing types // this member does not seem to benefit much from being override-able // so \"virtual\" modifier is omitted intentionally static TSelf InvariantParse(ReadOnlySpan\u003cchar\u003e s) =\u003e TSelf.Parse(s, CultureInfo.InvariantCulture); //provide standard *Parse methods implementation static virtual TSelf Parse(string s, IFormatProvider? provider) =\u003e TSelf.Parse(s.AsSpan(), provider); static virtual bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { result = default; if (s == null) return false; try { result = TSelf.Parse(s.AsSpan(), provider); return true; } catch (Exception) { return false; } } static virtual bool TryParse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { try { result = TSelf.Parse(s, provider); return true; } catch (Exception) { result = default; return false; } } } Let‚Äôs implement a simple class that will encapsulate notion of words that can be serialized in string separated with commas record CommaSeparatedWords(IReadOnlyList\u003cstring\u003e Words) : IMyParsable\u003cCommaSeparatedWords\u003e { public static CommaSeparatedWords Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider) { var words = new List\u003cstring\u003e(); foreach (var word in s.Split(',')) words.Add(word.ToString()); return new(words); } public override string ToString() =\u003e string.Join(\",\", Words); } CommaSeparatedWords record will have other Parse and TryParse methods but calling them directly will not be possible i.e. CommaSeparatedWords.TryParse(...). So how can one effectively use them? Answer remains in generic guards. static class MyParsableHelper { public static T ParseAs\u003cT\u003e(this string text, IFormatProvider? provider = null) where T : IMyParsable\u003cT\u003e =\u003e T.Parse(text, provider); } //usage: var words = \"A,B,C\".ParseAs\u003cCommaSeparatedWords\u003e(); But more probably this feature is more useful when wrapped in a class that delegates appropriate functionality. This class will parse line contents while delegating line parsing to CommaSeparatedWords: record Lines\u003cT\u003e(IReadOnlyList\u003cT\u003e Values) : IMyParsable\u003cLines\u003cT\u003e\u003e where T : IMyParsable\u003cT\u003e { public static Lines\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); //this also works in this context //var canParse = T.TryParse(\"\", provider, out var result); return new(lines); } public override string ToString() =\u003e string.Join(Environment.NewLine, Values); } So the following code will properly parse var parsedLines = Lines\u003cCommaSeparatedWords\u003e.Parse(\"\"\" Ala,has,a,cat Cat,has,Ala \"\"\"); as can be seen here: ","date":"2022-11-17","objectID":"/posts/static-interface-members/:1:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Generic math operations Let‚Äôs consider the following example interface IAdditionOperation\u003cT\u003e where T : IAdditionOperation\u003cT\u003e { static abstract T Zero { get; } static abstract T operator +(T lhs, T rhs); } record struct IntWrapper(int Value) : IAdditionOperation\u003cIntWrapper\u003e { public static IntWrapper Zero =\u003e new(0); public static IntWrapper operator +(IntWrapper lhs, IntWrapper rhs) =\u003e new(lhs.Value + rhs.Value); } //we can now write universal \"sum\" method for all IAdditionOperation\u003cT\u003e static T Sum\u003cT\u003e(IEnumerable\u003cT\u003e numbers) where T : IAdditionOperation\u003cT\u003e { var sum = T.Zero; foreach (var number in numbers) sum += number; return sum; //or: //return numbers.Aggregate(T.Zero, (acc, current) =\u003e acc + current); } //which can be used: var sum = Sum(Enumerable.Range(1, 10).Select(i =\u003e new IntWrapper(i))); We could easily create other number wrappers now (for float, long etc.) but that would be pointless. While this example is great for demonstration, one could argue that, in order for it to work, such generic interfaces should be built into .NET number type system. They are. In next post we will explore these concepts. ","date":"2022-11-17","objectID":"/posts/static-interface-members/:2:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Static polymorphism Distinction between shadowed and ‚Äúnew‚Äù overrides for instance members existed in C# practically since it‚Äôs inception. Let‚Äôs examine how it‚Äôs defined for static members interface IValues { static abstract string Static { get; } string Instance { get; } } class Base : IValues { public static string Static =\u003e \"Base\"; public string Instance =\u003e \"Base\"; } //this class shadows members class ShadowImpl : Base, IValues { public static string Static =\u003e \"Shadow\"; public string Instance =\u003e \"Shadow\"; } //this class defines \"new\" overrides class NewImpl : Base, IValues { public static new string Static =\u003e \"New\"; public new string Instance =\u003e \"New\"; } //we can now use generic method to print values static void Print\u003cT\u003e(T t) where T : IValues =\u003e Console.WriteLine(\"{0,6}, {1,6}\", T.Static, t.Instance); //and these are our results var @base = new Base(); var shadow = new ShadowImpl(); var @new = new NewImpl(); Base shadowAsBase = shadow; Base newAsBase = @new; Print(@base); // Base, Base Print(shadow); // Shadow, Shadow Print(@new); // New, New Print(shadowAsBase);// Base, Shadow Print(newAsBase); // Base, New So these examples show that we have static polymorphism in C# now üíñ. Whether you need that it‚Äôs up to you but I wonder when such concepts will find their ways into job interviews üòÄ ","date":"2022-11-17","objectID":"/posts/static-interface-members/:3:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"SIM in standard library ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Parsing One can assume that parsing is such important feature that appropriate interface should exist in standard library. It does, in 2 flavours in fact: IParsable ISpanParsable with later obviously extending the former. One can check, but most, if not all (with notable exception of bool), common types like int, float, byte already implement both of these interfaces. This in turn allows us to use them a generic guards to implement a CSV parser for lines with 3 constituents and a class that will store/parse whole CSV file: readonly record struct CsvLine\u003cT1, T2, T3\u003e(T1 Item1, T2 Item2, T3 Item3) : ISpanParsable\u003cCsvLine\u003cT1, T2, T3\u003e\u003e where T1 : ISpanParsable\u003cT1\u003e where T2 : ISpanParsable\u003cT2\u003e where T3 : ISpanParsable\u003cT3\u003e { public static CsvLine\u003cT1, T2, T3\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { // For some reasons ReadOnlySpan\u003cchar\u003e does not possess a string.Split() equivalent. // This example uses the SpanSplit approach from: // https://www.nuget.org/packages/Nemesis.TextParsers/ var enumerator = s.Split(',').GetEnumerator(); if (!enumerator.MoveNext()) throw new(\"No element at 1st position\"); var t1 = T1.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 2nd position\"); var t2 = T2.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 3rd position\"); var t3 = T3.Parse(enumerator.Current, CultureInfo.InvariantCulture); return new(t1, t2, t3); } //remaining Parse methods omitted for brevity } record CsvFile\u003cT\u003e(IReadOnlyList\u003cT\u003e Lines) : ISpanParsable\u003cCsvFile\u003cT\u003e\u003e where T : ISpanParsable\u003cT\u003e { public static CsvFile\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); return new(lines); } //remaining Parse methods omitted for brevity } This will allow parsing to be done in following fashion: var parsedNumbers = CsvFile\u003cint\u003e.Parse(\"\"\" 11 22 33 \"\"\"); //or more advanced example var parsedStructs = CsvFile\u003cCsvLine\u003cint, float, char\u003e\u003e.Parse(\"\"\" 11,1.1,A 22,2.2,B 33,3.3,C \"\"\"); ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:1","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Generic math operation This topic is quite comprehensive. Stay tuned for a separate blog post. It‚Äôs scheduled for 5th of December 2022. We will attempt to implement whole generic type using new constructs ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:2","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Sources Static Interface Members ","date":"2022-11-17","objectID":"/posts/static-interface-members/:5:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["math"],"content":"In modern times we often need a way to send messages in a covert way, without revealing a key prior to transfer. It can be achieved using systems with public/private keys. Let‚Äôs explore these concepts today. ","date":"2022-10-28","objectID":"/posts/rsa-cipher/:0:0","tags":["cryptography","legacy"],"title":"Public key cryptosystems and RSA","uri":"/posts/rsa-cipher/"},{"categories":["math"],"content":"Public key cryptography algorithm Let‚Äôs consider a system where there exist 2 different, but mathematically connected keys - a private and public one. As the name suggest, a public one is publicly available whereas private is know only privately stored by message sender. Such cryptosystem can be used for encryption/decryption of messages but also for signing/verification of message hashes. This process can (but not always) follow (signature part is optional): ","date":"2022-10-28","objectID":"/posts/rsa-cipher/:1:0","tags":["cryptography","legacy"],"title":"Public key cryptosystems and RSA","uri":"/posts/rsa-cipher/"},{"categories":["math"],"content":"Knapsack Encryption Algorithm Knapsack Encryption Algorithm is considered to be first public key cryptosystem. This variation on knapsack problem was proposed in 1978 by Ralph Merkle and Martin Hellman. It uses 2 different knapsack problem parameters. Easy knapsack is used as a private key and hard knapsack is used as a public key. Hard knapsack is subsequently derived from an easy knapsack. ","date":"2022-10-28","objectID":"/posts/rsa-cipher/:2:0","tags":["cryptography","legacy"],"title":"Public key cryptosystems and RSA","uri":"/posts/rsa-cipher/"},{"categories":["math"],"content":"Example Let‚Äôs consider the following knapsack defined by superincreasing sequence: This sequence satisfies for every $ n ‚â• 1 $ For this sequence let‚Äôs perform encryption and decryption: Fix arbitrary numbers m and n so that m has value larger that sum of all elements of S (say 421) and n co-prime to m (say 69) Co-prime Two integers are considered co-prime if the only positive integer that divides them is 1 Multiply all values of S by n modulo m thus obtaining a public key $$ Key_{pub} = Key_{priv} \\times 69\\ \\mathbf{mod}\\ 421\\ = [69, 207, 414, 55, 179, 220, 371, 321] $$ Calculate modular multiplicative inverse $n^{-1}$ so that $$ n \\times n^{-1} \\equiv 1 \\pmod{m} $$ so $ n^{-1} = 360$. $ n^{-1} $ as well as $ n $ should only be known to recipient of encrypted message assume message M to be ‚ÄúABC‚Äù, encoded in standard ASCII that would be $$ M = [ 01000001_{(2)}, 01000010_{(2)}, 01000011_{(2)} ] $$ Multiply all binary values by corresponding values from public key $$ Enc = [207+321, 207+371, 207+371+321] = \\newline {\\large [528, 578, 899]} $$ For decryption we need to multiply each value in encrypted string by $ n^{-1} $ to ‚Äúcancel out‚Äù previous multiplication by $ n $ $$ Dec = [528, 578, 899] \\times n^{-1}\\ \\mathbf{mod}\\ m\\ = \\newline [528, 578, 899] \\times 360\\ \\mathbf{mod}\\ 421 = \\newline {\\large [209, 106, 312] } $$ Every element represents cumulative value of a knapsack problem given by our private key. Since our knapsack values are superincreasing, then solution is unequivocal Let‚Äôs see how can we obtain these values from private key Decrypted vales correspond to our original binary sequence $$ [ 01000001_{(2)}, 01000010_{(2)}, 01000011_{(2)} ] $$ ","date":"2022-10-28","objectID":"/posts/rsa-cipher/:2:1","tags":["cryptography","legacy"],"title":"Public key cryptosystems and RSA","uri":"/posts/rsa-cipher/"},{"categories":["math"],"content":"Practical applications While fairly easy to understand, this approach has some downsides. Due to the fact that polynomial time attack was proposed by Adi Shamir and another by Leonard Alderman this cryptosystem is now considered insecure. ","date":"2022-10-28","objectID":"/posts/rsa-cipher/:2:2","tags":["cryptography","legacy"],"title":"Public key cryptosystems and RSA","uri":"/posts/rsa-cipher/"},{"categories":["csharp"],"content":"Recently we‚Äôve been seeing an increased activities on various blogs due to upcoming .NET 5 release date and one of it‚Äôs hottest feature - C# 9.0 records. A lot was written about this feature, starting with MSDN. What was not clear however, was whether one can use records in older frameworks - like .NET 4.8. Tip To be able to run all of following examples to the fullest extent, make sure your language version is set to 9.0 or larger (i.e. in *.csproj file) \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:0:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Anatomy of record positional properties Let‚Äôs settle our attention on the following example record Vertebrate(string Name) { public Vertebrate() : this(\"\") { } } public enum Habitat { Terrestrial, Aquatic, Amphibian } public record Reptile(Habitat Habitat) : Vertebrate { } Upon compilation under net5.0 framework moniker, everything works as expected. Change it to however to net48 and you will not be able to compile it. This compiler feature fortunatelly works like opt-in member resolution (similarly to string interpolation). What compiler needs in this case is an accessible class of the following structure so that init-only properties are accessible //TODO: use appropriate compiler directives for legacy targets - it's not needed in net5.0+ #if NETSTANDARD2_0 namespace System.Runtime.CompilerServices { [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] internal static class IsExternalInit { } } #endif ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Check if property is init-only After quick research one can spot that init-only setter has special structure: .set instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) DotnetCommunityDemoNet5.Records/Vertebrate::set_Name(string) To determine that setter is init-only one just needs to query the existence of required modifier initialized with aforementioned IsExternalInit type - this code helper should do the trick: public static class RecordsHelper { public static bool IsInitOnly(this PropertyInfo property) =\u003e property.CanWrite \u0026\u0026 property.SetMethod is var setter \u0026\u0026 setter.ReturnParameter.GetRequiredCustomModifiers() is var reqMods \u0026\u0026 reqMods.Length \u003e 0 \u0026\u0026 Array.IndexOf(reqMods, typeof(System.Runtime.CompilerServices.IsExternalInit)) \u003e -1; } ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:1","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Consuming records in older frameworks Tip Records are not any special types - they are, per se, not specially recognized by CLI/CLR. They are just specially designed classes with: init only properties (default behavior for positional records) automatic structural equality, IEquatable\u003c\u003e implementation, equality operators positional deconstruction printing/formatting Due to this phenomenon, consuming records is quite straightforward - you are using them as normal classes. So even older C# versions will be able to use it straight away. If you‚Äôd like to use with keyword then you need to use C# 9.0+ for instance by specifying that in *.csproj file of your target project: \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e and you‚Äôll be able to use all record features upon consumption: ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:2:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Sources Records producer/consumer ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:3:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":null,"content":"Micha≈Ç Bry≈Çka Managing software developer, tech lead. Interested in systems design and normalization with performance as his priority. Experienced in smart client applications development, compiler writing, optimization, algorithmics. Clean code advocate, performance enthusiast, .Net freak Specialties: .Net (especially C# and VB.Net) Kotlin databases (MS SQL Server, Oracle) server-side technologies (ASP.Net) #compilerIsSexy #highPerf #Roslyn #superFast #SIMD ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]