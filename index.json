[{"categories":null,"content":"fddfdfdfdfdfdffddf 123 This is a tip A tip banner $$ \\ce{CO2 + C -\u003e 2 CO} $$ $c =\\mathbf{E}=\\sum_{i} \\mathbf{E}_{i} $ Block Formula: $c = \\pm\\sqrt{a^2 + b^2}$ and \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) ","date":"2022-11-02","objectID":"/posts/my-first-post/:0:0","tags":null,"title":"My First Post","uri":"/posts/my-first-post/"},{"categories":["csharp"],"content":"Recenly we’ve been seeing an increased activities on various blogs due to upcoming .NET 5 release date and one of it’s hottest feature - C# 9.0 records. A lot was written about this feature, starting with MSDN. What was not clear however, was whether one can use records in older frameworks - like .NET 4.8. ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:0:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Anatomy of init-only properties Let’s settle our attention on the following example record Vertebrate(string Name) { public Vertebrate() : this(\"\") { } } public enum Habitat { Terrestrial, Aquatic, Amphibian } public record Reptile(Habitat Habitat) : Vertebrate { } Upon compilation under net5.0 framework moniker, everything works as expected. Change it to however to net48 and you will not be able to compile it. This compiler feature fortunatelly works like opt-in member resolution (similarly to string interpolation). What compiler needs in this case is an accessible class of the following structure //TODO: use appropriate compiler directives for legacy targets - it's not needed in net5.0 #if NETSTANDARD2_0 namespace System.Runtime.CompilerServices { [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] internal static class IsExternalInit { } } #endif ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Check if property is init-only After quick research one can spot that init-only setter has special structure: .set instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) DotnetCommunityDemoNet5.Records/Vertebrate::set_Name(string) To determine that setter is init-only one just needs to query the existence of required modifier initialized with aforementioned IsExternalInit type - this code helper should do the trick: public static class RecordsHelper { public static bool IsInitOnly(this PropertyInfo property) =\u003e property.CanWrite \u0026\u0026 property.SetMethod is var setter \u0026\u0026 setter.ReturnParameter.GetRequiredCustomModifiers() is var reqMods \u0026\u0026 reqMods.Length \u003e 0 \u0026\u0026 Array.IndexOf(reqMods, typeof(System.Runtime.CompilerServices.IsExternalInit)) \u003e -1; } ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:1","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Consuming records in older frameworks Tip Records are not any special types - they are, per se, not specially recognized by CLI/CLR. They are just spcially designed classes with: init only properties (default behaviour for positional records) authomatic structural equality, IEquatable\u003c\u003e implementation, equality operators positional deconstruction printing/formatting Due to this phenomenon, consuming records is quite straightforward - you are using them as normal classes. If you’d like to use with keyword then you need to use C# 9.0+ for instance by specifying that in *.csproj file: \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:2:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Sources Records producer/consumer ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:3:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":null,"content":"Michał Bryłka Managing software developer, tech lead. Interested in systems design and normalization with performance as his priority. Experienced in smart client applications development, compiler writing, optimization, algorithmics. Clean code advocate, performance enthusiast, .Net freak Specialties: .Net (especially C# and VB.Net) Kotlin databases (MS SQL Server, Oracle) server-side technologies (ASP.Net) #compilerIsSexy #highPerf #Roslyn #superFast #SIMD ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]