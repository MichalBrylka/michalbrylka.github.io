[{"categories":["csharp"],"content":"C# 8.0 gave us default interface methods. They brought us, among other things, the way to introduce new API members without breaking current contracts. Interfaces however still lacked a ability to model ‚Äústatic‚Äù members out-of-the-box. Factories became our usual way of dealing with object creation but how about functionalities that class itself knows best how to handle. What about, say, parsing? Enter C# 11‚Äôs Static Interface Members ","date":"2022-11-17","objectID":"/posts/static-interface-members/:0:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Parsing Let‚Äôs examine the following example: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); } First that strikes to mind is ‚Äúwhat do we need such generic guard here?‚Äù. Read more on Curiously Recurring Generic Pattern. CRGP It get‚Äôs a little tricky to use Curiously Recurring Generic Pattern correctly to the point that even special syntax was proposed for it but none of these proposals were championed. For now, do not worry about it, just do not copy and paste such code like there is no tomorrow. Rest of the example seems reasonable - this states that types implementing this interface must also contain static Parse method. This method can be used inside interface itself: public interface IMyParsable\u003cTSelf\u003e where TSelf : IMyParsable\u003cTSelf\u003e? { static abstract TSelf Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider); //provide implementation in implementing types // this member does not seem to benefit much from being override-able // so \"virtual\" modifier is omitted intentionally static TSelf InvariantParse(ReadOnlySpan\u003cchar\u003e s) =\u003e TSelf.Parse(s, CultureInfo.InvariantCulture); //provide standard *Parse methods implementation static virtual TSelf Parse(string s, IFormatProvider? provider) =\u003e TSelf.Parse(s.AsSpan(), provider); static virtual bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { result = default; if (s == null) return false; try { result = TSelf.Parse(s.AsSpan(), provider); return true; } catch (Exception) { return false; } } static virtual bool TryParse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider, [MaybeNullWhen(false)] out TSelf result) { try { result = TSelf.Parse(s, provider); return true; } catch (Exception) { result = default; return false; } } } Let‚Äôs implement a simple class that will encapsulate notion of words that can be serialized in string separated with commas record CommaSeparatedWords(IReadOnlyList\u003cstring\u003e Words) : IMyParsable\u003cCommaSeparatedWords\u003e { public static CommaSeparatedWords Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider) { var words = new List\u003cstring\u003e(); foreach (var word in s.Split(',')) words.Add(word.ToString()); return new(words); } public override string ToString() =\u003e string.Join(\",\", Words); } CommaSeparatedWords record will have other Parse and TryParse methods but calling them directly will not be possible i.e. CommaSeparatedWords.TryParse(...). So how can one effectively use them? Answer remains in generic guards. static class MyParsableHelper { public static T ParseAs\u003cT\u003e(this string text, IFormatProvider? provider = null) where T : IMyParsable\u003cT\u003e =\u003e T.Parse(text, provider); } //usage: var words = \"A,B,C\".ParseAs\u003cCommaSeparatedWords\u003e(); But more probably this feature is more useful when wrapped in a class that delegates appropriate functionality. This class will parse line contents while delegating line parsing to CommaSeparatedWords: record Lines\u003cT\u003e(IReadOnlyList\u003cT\u003e Values) : IMyParsable\u003cLines\u003cT\u003e\u003e where T : IMyParsable\u003cT\u003e { public static Lines\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); //this also works in this context //var canParse = T.TryParse(\"\", provider, out var result); return new(lines); } public override string ToString() =\u003e string.Join(Environment.NewLine, Values); } So the following code will properly parse var parsedLines = Lines\u003cCommaSeparatedWords\u003e.Parse(\"\"\" Ala,has,a,cat Cat,has,Ala \"\"\"); as can be seen here: ","date":"2022-11-17","objectID":"/posts/static-interface-members/:1:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Generic math operations Let‚Äôs consider the following example interface IAdditionOperation\u003cT\u003e where T : IAdditionOperation\u003cT\u003e { static abstract T Zero { get; } static abstract T operator +(T lhs, T rhs); } record struct IntWrapper(int Value) : IAdditionOperation\u003cIntWrapper\u003e { public static IntWrapper Zero =\u003e new(0); public static IntWrapper operator +(IntWrapper lhs, IntWrapper rhs) =\u003e new(lhs.Value + rhs.Value); } //we can now write universal \"sum\" method for all IAdditionOperation\u003cT\u003e static T Sum\u003cT\u003e(IEnumerable\u003cT\u003e numbers) where T : IAdditionOperation\u003cT\u003e { var sum = T.Zero; foreach (var number in numbers) sum += number; return sum; //or: //return numbers.Aggregate(T.Zero, (acc, current) =\u003e acc + current); } //which can be used: var sum = Sum(Enumerable.Range(1, 10).Select(i =\u003e new IntWrapper(i))); We could easily create other number wrappers now (for float, long etc.) but that would be pointless. While this example is great for demonstration, one could argue that, in order for it to work, such generic interfaces should be built into .NET number type system. They are. In next post we will explore these concepts. ","date":"2022-11-17","objectID":"/posts/static-interface-members/:2:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Static polymorphism Distinction between shadowed and ‚Äúnew‚Äù overrides for instance members existed in C# practically since it‚Äôs inception. Let‚Äôs examine how it‚Äôs defined for static members interface IValues { static abstract string Static { get; } string Instance { get; } } class Base : IValues { public static string Static =\u003e \"Base\"; public string Instance =\u003e \"Base\"; } //this class shadows members class ShadowImpl : Base, IValues { public static string Static =\u003e \"Shadow\"; public string Instance =\u003e \"Shadow\"; } //this class defines \"new\" overrides class NewImpl : Base, IValues { public static new string Static =\u003e \"New\"; public new string Instance =\u003e \"New\"; } //we can now use generic method to print values static void Print\u003cT\u003e(T t) where T : IValues =\u003e Console.WriteLine(\"{0,6}, {1,6}\", T.Static, t.Instance); //and these are our results var @base = new Base(); var shadow = new ShadowImpl(); var @new = new NewImpl(); Base shadowAsBase = shadow; Base newAsBase = @new; Print(@base); // Base, Base Print(shadow); // Shadow, Shadow Print(@new); // New, New Print(shadowAsBase);// Base, Shadow Print(newAsBase); // Base, New So these examples show that we have static polymorphism in C# now üíñ. Whether you need that it‚Äôs up to you but I wonder when such concepts will find their ways into job interviews üòÄ ","date":"2022-11-17","objectID":"/posts/static-interface-members/:3:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Static Interface Members in standard library ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Parsing One can assume that parsing is such important feature that appropriate interface should exist in standard library. It does, in 2 flavours in fact: IParsable ISpanParsable with later obviously extending the former. One can check, but most, if not all (with notable exception of bool), common types like int, float, byte already implement both of these interfaces. This in turn allows us to use them a generic guards to implement a CSV parser for lines with 3 constituents and a class that will store/parse whole CSV file: readonly record struct CsvLine\u003cT1, T2, T3\u003e(T1 Item1, T2 Item2, T3 Item3) : ISpanParsable\u003cCsvLine\u003cT1, T2, T3\u003e\u003e where T1 : ISpanParsable\u003cT1\u003e where T2 : ISpanParsable\u003cT2\u003e where T3 : ISpanParsable\u003cT3\u003e { public static CsvLine\u003cT1, T2, T3\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { // For some reasons ReadOnlySpan\u003cchar\u003e does not possess a string.Split() equivalent. // This example uses the SpanSplit approach from: // https://www.nuget.org/packages/Nemesis.TextParsers/ var enumerator = s.Split(',').GetEnumerator(); if (!enumerator.MoveNext()) throw new(\"No element at 1st position\"); var t1 = T1.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 2nd position\"); var t2 = T2.Parse(enumerator.Current, CultureInfo.InvariantCulture); if (!enumerator.MoveNext()) throw new(\"No element at 3rd position\"); var t3 = T3.Parse(enumerator.Current, CultureInfo.InvariantCulture); return new(t1, t2, t3); } //remaining Parse methods omitted for brevity } record CsvFile\u003cT\u003e(IReadOnlyList\u003cT\u003e Lines) : ISpanParsable\u003cCsvFile\u003cT\u003e\u003e where T : ISpanParsable\u003cT\u003e { public static CsvFile\u003cT\u003e Parse(ReadOnlySpan\u003cchar\u003e s, IFormatProvider? provider = null) { var splitText = s.EnumerateLines(); var lines = new List\u003cT\u003e(); foreach (var line in splitText) lines.Add(T.Parse(line, provider)); return new(lines); } //remaining Parse methods omitted for brevity } This will allow parsing to be done in following fashion: var parsedNumbers = CsvFile\u003cint\u003e.Parse(\"\"\" 11 22 33 \"\"\"); //or more advanced example var parsedStructs = CsvFile\u003cCsvLine\u003cint, float, char\u003e\u003e.Parse(\"\"\" 11,1.1,A 22,2.2,B 33,3.3,C \"\"\"); ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:1","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Generic math operation This topic is quite comprehensive. Stay tuned for a separate blog post. It‚Äôs scheduled for 5th of December 2022. ","date":"2022-11-17","objectID":"/posts/static-interface-members/:4:2","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Sources Static Interface Members ","date":"2022-11-17","objectID":"/posts/static-interface-members/:5:0","tags":["architecture","interface"],"title":"Static Interface Members","uri":"/posts/static-interface-members/"},{"categories":["csharp"],"content":"Recently we‚Äôve been seeing an increased activities on various blogs due to upcoming .NET 5 release date and one of it‚Äôs hottest feature - C# 9.0 records. A lot was written about this feature, starting with MSDN. What was not clear however, was whether one can use records in older frameworks - like .NET 4.8. Tip To be able to run all of following examples to the fullest extent, make sure your language version is set to 9.0 or larger (i.e. in *.csproj file) \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:0:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Anatomy of record positional properties Let‚Äôs settle our attention on the following example record Vertebrate(string Name) { public Vertebrate() : this(\"\") { } } public enum Habitat { Terrestrial, Aquatic, Amphibian } public record Reptile(Habitat Habitat) : Vertebrate { } Upon compilation under net5.0 framework moniker, everything works as expected. Change it to however to net48 and you will not be able to compile it. This compiler feature fortunatelly works like opt-in member resolution (similarly to string interpolation). What compiler needs in this case is an accessible class of the following structure so that init-only properties are accessible //TODO: use appropriate compiler directives for legacy targets - it's not needed in net5.0+ #if NETSTANDARD2_0 namespace System.Runtime.CompilerServices { [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] internal static class IsExternalInit { } } #endif ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Check if property is init-only After quick research one can spot that init-only setter has special structure: .set instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) DotnetCommunityDemoNet5.Records/Vertebrate::set_Name(string) To determine that setter is init-only one just needs to query the existence of required modifier initialized with aforementioned IsExternalInit type - this code helper should do the trick: public static class RecordsHelper { public static bool IsInitOnly(this PropertyInfo property) =\u003e property.CanWrite \u0026\u0026 property.SetMethod is var setter \u0026\u0026 setter.ReturnParameter.GetRequiredCustomModifiers() is var reqMods \u0026\u0026 reqMods.Length \u003e 0 \u0026\u0026 Array.IndexOf(reqMods, typeof(System.Runtime.CompilerServices.IsExternalInit)) \u003e -1; } ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:1:1","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Consuming records in older frameworks Tip Records are not any special types - they are, per se, not specially recognized by CLI/CLR. They are just specially designed classes with: init only properties (default behavior for positional records) automatic structural equality, IEquatable\u003c\u003e implementation, equality operators positional deconstruction printing/formatting Due to this phenomenon, consuming records is quite straightforward - you are using them as normal classes. So even older C# versions will be able to use it straight away. If you‚Äôd like to use with keyword then you need to use C# 9.0+ for instance by specifying that in *.csproj file of your target project: \u003cPropertyGroup\u003e \u003cLangVersion\u003e9.0\u003c/LangVersion\u003e \u003c/PropertyGroup\u003e and you‚Äôll be able to use all record features upon consumption: ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:2:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":["csharp"],"content":"Sources Records producer/consumer ","date":"2020-06-11","objectID":"/posts/using-records-in-older-frameworks/:3:0","tags":["records","legacy"],"title":"Using Records in legacy .NET Frameworks","uri":"/posts/using-records-in-older-frameworks/"},{"categories":null,"content":"Micha≈Ç Bry≈Çka Managing software developer, tech lead. Interested in systems design and normalization with performance as his priority. Experienced in smart client applications development, compiler writing, optimization, algorithmics. Clean code advocate, performance enthusiast, .Net freak Specialties: .Net (especially C# and VB.Net) Kotlin databases (MS SQL Server, Oracle) server-side technologies (ASP.Net) #compilerIsSexy #highPerf #Roslyn #superFast #SIMD ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]